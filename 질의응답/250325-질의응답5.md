
# 3월 25일 질의응답

## 숲님: 라이프사이클
### main Loop가 하는 역할
- 사용자의 이벤트나 외부 이벤트가 발생했을 때 하나씩 처리하는 역할
- 각 이벤트들이 앱에서 어떻게 반영이 되어야하는 지 처리하는 역할을 수행한다
  
### 이벤트들은 어떤 형태로 main run loop에 랩핑이 되는가?
- Queue를 통해 이벤트가 랩핑되는 것을 알지만, 어떤 형태로 랩핑되는지는 어떤 의미인지
  
###  앱 사용중에 다른 앱의 푸쉬 알림이 온 경우 호출되는 메서드가 있는지
- 앱 델리게이트에서 푸쉬 알림을 감지하고, main run loop에 queue를 통해 순서 대로 처리된다. 하지만, 어떤 메서드가 호출되는지는 잘 모르겠다.
  - 노티가 온 경우에는 앱이 아무런 영햘도 받지 않기 때문에 이를 의도한 질문이였다.
 
### 앱 A가 백그라운드에 있을 때 시스템에 의해 완전히 종료되는 경우 개발자가 알 수 있는 방법이 있는지
- 백그라운드에서 서스팬디드로 이동할 땐 메서드를 통해 종료되는지 알 수는 있을 것 같다.
- 하지만, 현재 앱 상태에 따라 다를 수 있을 것 같다.
  - 시스템에 의해 앱이 강제 종료될 때 이벤트가 무시되는 경우도 있었다.
  - 메모리 부족으로 인한 것은 푸쉬 못 띄우는 거 맞음 백그라운드에서 서스펜드로 가야만 종료할 수 있음
 
###  SceneDelegate가 나중에 추가가 됐는데, 왜 필요했을지 설명해 줄 수 있는가?
- SceneDelegate은 iOS13 이후부터 도입됨, 그 이전 까지는 AppDelegate이 모든 역할을 맡고 있었음. 그게 가능했던 이유는, 하나의 화면에 하나의 앱만 있었기 때문임.
- 13이후에는 한 화면의 멀티 윈도우가 추가가 됐었음. 이에 따라 씬을 관리해야할 필요성을 느꼈음.
- Scene에 하나의 윈도우의 UI 관리를 맡기고, App 에서는 Scene이 담긴 세션을 관리하는 역할을 하도록 분리함.

## 시원님: 오류 흐름 혼잡 제어

### TCP에서 흐름제어와 혼잡제어의 차이는?
- 흐름제어는 서버가 한번에 처리할 수 잇는 세그먼트의 수를 클라이언트에게 보내주면서 클라이언트가 그만큼만 서버에게 전송하는 기법
- 혼잡제어는 동적으로 변하는 네트워크환경에 따라(대역폭) 처리할 수 있는 세그먼트의 수를 점차 늘여가며 손실이 발생하지 않는 방법.

### TCP에서 Segment가 누락, 손실 되면 어덯게 알고 어떻게 복구를 하는가
- 오류제어를 통해 손실 감지, 재전송을 한다
- 오류제어의 기준은
  1. 세그먼트를 보내고, ACK 를 받지 못했을 때
  2. 동일한 ACK를 세번연속 받았을 때. 발신측은 이를 오류로 판단한다.
 
### 흐름 제어에서 이제 슬라이딩 윈도우가 사용되는데 그거에 대해서 설명해 주세요.
- 서버가 한 번에 처리할 수 있는 세그먼트의 크기에 따라서 윈도우의 사이즈가 결정이 되고 그 이제 클라이언트는 그 윈도우만큼의 세그먼트를 이제 순차적으로 보내게 됩니다.

### 아떤 경우 윈도우가 슬라이딩 되는지 설명해주세요.
-  보낸 세그먼트에 대해서 이제 ACK를 받은 경우 이제 해당 세그먼트는 처리했다고 인지하고 이제 다음 세그먼트를 보내는 과정에서 이제 이 슬라이드가 윈도우가 움직이는 것처럼 보여진다 라고 해서 그렇게 불려지는 것 같습니다.

### 만약 특정 세그먼트에서 지속적인 오류가 발생한다면 다음 세그먼트들은 무한정 기다리게 되는지?
-  TCP는 신뢰성을 보장하기 때문에 무한정 기다릴 것 같다.
  - TCP의 신뢰성을 언급해주셨기 때문에 납득이 되는 것 같다.

## 인예님: iOS 메모리

### ios에서 메모리를 관리하는 방식에 대해 설명해주세요
- iOS는 이제 보통 다른 운영 체제에서 진행하는 스워핑을 사용하지 않고 이제 오랫동안 접근되지 않은 데이터를 압축을 하는 방식을 사용합니다.
### 왜 ios는 스왑이 아닌 압축을 선택했을까?
- 디스크IO 처리 시간이 발생하다보니 이를 최적화하기 위해 압축 기법을 선택한 것 같다.
  - 단순히 이제 디스크 접근을 안 해서 속도가 빠른 것도 있지만, SSD 수명과, 배터리 전력 효율에도 관련이 있어보인다.
  - 가상 메모리 주제에서 나온 페이지 테이블 사용 여부 또한 차이가 있을 것 같다.
 
### 메모리에서 가장 큰 공간을 차지하는게 이미지라고 생각하는데 ios는 이미지를 어떻게 처리하나요?
- ios는 개발자가 이미지를 처리할 수 있는 api를 제공한다.
- 크게 그 이미지 전체를 이제 압축 해제해서 메모리에 올리는 방식이 있고 그다음에 이제 라이브 형식으로 필요한 부분만 메모리에 올리는 API도 제공을 하고 있습니다.
- 때문에 이미지가 조금 파일이 크고 용량이 크다 하면은 그렇게 필요한 부분만 메모리에 올리는 방식을 개발자가 선택을 해서 메모리를 줄일 수 있습니다.

### 개발자가 1차적으로 ios에서 제공하는 api를 활용해서 이미지의 사이즈를 줄일 수 있는데 그럼에도 이미지의 양 혹은 크기가 너무 크다면 추가적으로 차리할 수 있는 방법이 있나요?
- 이미지가 잠시 보이지 않을 때 해당 이미지를 메모리에서 탈락시키고, 다시 보여질 때 메모리에 올리는 방식을 사용한다면, 더 효율적으로 메모리 공간을 사용할 수 잇을 것 같다.
  - downsampling을 의도하긴 했지만, 현재 사용하지 않는 이미지를 잠깐 메모리에서 해제 시키는 것도 좋은 방법인 것 같다.
 
### ios에서는 HEIC 파일 확장자를 사용하는데 혹시 메모리 관리 방식에 차이가 있나요?
-  메모리 관리 방식이 다르다기보다는 압축하는 방식이 다를 거라고 생각을 합니다.

### 이미지를 좀 여러 개를 띄워서 좀 가려졌을 때는 그 부분에 대해서는 메모리가 해제되고 그 위에 가려버린 이미지로 다시 재할당이 되는 건가요?
- 가려진다고 해서 메모리가 해지가 되지는 않을 것 같아요. 왜냐하면 결국에는 뒤에 어쨌든 보여지고 있는 상태라고 인식이 되지 않을까 생각합니다.
