# 2월 11일 질의응답

## 회의에 앞서
- 이불 밖을 나가기 싫다.
- 너무 춥다
- 질문은 손들어서 하고싶은 사람이 하도록 하기

## 현준님: 프로세스와 스레드

### 인예님 질문

Q. 프로세스를 fork하는 대신에 스레드를 사용하는 것이 왜 더 효율적인가요?

A. 각 프로세스들은 자원을 공유하지 않아 컨텍스트 스위칭이 일어날 때 가상메모리에 올라간 모든 데이터가 변경돼야 하지만, 스레드는 각 프로세스 안에서 코드와 데이터를 공유하고 있기 때문에 스위칭에 더 적은 오버헤드가 발생합니다. 

Q. 스레드 간에는 데이터를 공유한다고했는데 안전하게 공유하기 위해서는 어떻게 해야할까?
mutex를 공부하였나?

A. 답변을 거부한다. 너무 다른 이야기다. 

Q. 스레드를 사용할 때 발생할 수 있는 문제는 어떠한 것들이 있는가?

A. 공유 자원을 사용하고 있으므로 자원에 대한 접근을 확실히 해야 공유된 자원에 대해서 data-race가 발생하거나 lock이 걸렸을 때 dead lock 상태가 발생하지 않도록 공유자원 사용에 주의를 기울여야 한다고 생각합니다. 

### 승재님 질문

Q. 운영체제는 프로세스를 어떻게 관리하고있나요?

A. 커널에서 관리하는데 PCB라는 모델로 관리를 하고있다. PCB 프로세스의 고유 번호, 상태, 다음 명령어 주소, 레지스터 값들이 있고, 커널에서 프로세스 관련 데이터를 로드하고 진행되는 프로세스를 인터럽트, 시스템 콜이 일어날 때 변경하는 일을 하고 이를 컨텍스트 스위치라고 합니다. 

(인예님 꼬리질문) Q. 컨텍스트 스위칭을 할 때 꼭 필요한 것은?

A. 프로세스의 고유번호, 프로세스를 커널에서 로드할 때 CPU의 실행상태, 명령어 주소, 실행 상태 필요하다

인예님 A. 그 정보들도 PCB에 저장되어 있다. 

### 건우님 질문

PCB에서 CPU의 상태를 말씀하셨는데, CPU의 상태도 중요하나 컨텍스트 스위칭이 핵심이므로 프로세스의 상태를 이야기 하는것이 더 중요하지 않나싶다. 


## 시원님: 프레임워크와 라이브러리

### 인예님 질문

Q. 서드 파티 라이브러리를 많이 사용한다면 앱에 어떤 영향을 미칠지? 이 문제를 해결하기 위해서는 어떻게 해야하나

A. 스태틱인지 다이나믹인지에 따라 다를 것이다

링크 작업이 많이 발생하기 때문에 링크 하는데 걸리는 시간이 걸릴 것 같다. 

해결 방안으로는 하나로 묶어주는 것 

인예님 답변 Easy Layout 만들었을때의 경험을 같이 이야기 했어도 좋았을 것 같다. (서드파티를 사용하지 않고 필요한 부분만 만들어 사용하는 것이 좋을 것 같다)

Q. 라이브러리와 프레임워크의 공통점 차이점 

A. 둘 다 앱에서 독립적으로 배포되고, 관리될 수 있는 소스코드의 집합

라이브러리는 소스코드의 집합에 더 강조가 되어있고
프레임워크는 리소스가 더 추가될 수 있음
배포되는 과정에서도 조금 차이가 있다. 
라이브러리 는 오브젝트 파일로 생성
프레임 워크는 내부 계층적으로 디렉토리로 구성이 되고 실행 파일도 독립적으로 갖고 있다.

프레임워크는 디렉토리 구조를 갖고 있기 때문에 더 많은 정보들을 갖고 있다. 

Q. static & Dynamic Library 의 장단점?

컴파일시 앱 실행파일에 포함 됨
다이나믹은 직접으로 포함되진 않고 Linker를 통해 특정 경로를 통해서 해당 코드가 실행될 때 실행코드를 순간의 스택으로 할당을 하고 읽어들여와 실행한다.

스태틱 라이브러리의 장점은 빠르다. 빠른 접근, 단점은 앱 실행파일의 용량이 커진다. 관계가 복잡해졌을 때 중복적으로 여러 프레임워크 라이브러리에 중복적으로 카피될 가능성이 있다

다이나믹 라이브러리는 직접 복사가 아니라 참조관계로 접근하기 때문에 스태틱라이브러리에서 발생할 수 있는 문제가 해결될 수 있다. 하지만 참조를 통해 접근하기 때문에 코드 접근 속도가 느릴 수 있다. 
접근 속도보다는 앱실행파일의 사이즈나 코드 중복 문제가 더 치명적이라 생각한다. 

Q. 정적 라이브러리를 사용할 때 중복 사용이 문제라 했는데 이것의 해결방안이 다이나믹 밖에 없나?

중복이 발생하지 않도록 참조구조를 설계를 잘 하는것이 더 중요하다. 다만 위험성이 있는 것 보다는 다이나믹을 사용하는 것이 훨씬 더 확실할 것 같다. 

Q. 구조를 짠다면?

하나의 상위 모듈이 라이브러리를 참조하고 static 라이브러리를 참조한 모듈을 참조 시켜서 구조를 짤 것 같다. 
static라이브러리가 하나의 

수직적으로 라이브러리를 참조하게 되면 Xcode에서 사용하는 증분 빌드의 이점을 챙길 수 없을 것 같다. 

Q. iOS에서 다이나믹 라이브러리가 제공되지 않는 이유?

A. 지원되지 않는 이유는 사실 OS 문제라고 생각한다. 다이나믹 라이브러리를 iOS에서 사용했을 때 라이브러리는 번들구조에 포함시킬 수 없는 구조이기 때문에 프레임워크를 사용할 수 밖에 없다. 프레임워크는 번들구조에 포함 시킬지 말지를 선택 가능하다.  

 외부에서는 영향을 주지 못하도록 하는 것이 중요하다. 이것이 iOS의 샌드박스정책과 대립되기 때문에 dynamic Library 를 사용할 수 없다.

Q. 다이나믹 라이브러리인데 왜 스태틱 링커가 필요한가? 

위치를 기록 하는 것이 링커
어떤 것을 카피할 지 링커에 포함 되어있다.
스태틱 링커는 카피할 때 딱 한 번만 사용.

스태틱 라이브러리는 경로는 없고 파일 명만 존재한다. 위치는 존재하나 접근하는 rpath만 존재한다.

건우님 생각: 라이브러리와 프레임워크 이야기 할 때 라이브러리는 효율성, 속도가 떨어진다 -> 앱은 사용자에게 속도가 중요하므로 핸드폰 자체가 Mac같은 워크스테이션 보다는 성능이 떨어지므로 속도를 중요하게 생각해야하기 때문에 Dynamic 라이브러리를 사용 하지 않을까?


ABI 뭐징~?
시원님: 나도 몰라~~~~ 


HJ: ABI 문제가 대체 뭔데? 
IY: 바이너리 코드와 호환이 안된다. 맥은 되고 iOS 는 안된다.
## 민하: ARC

메모리 관리 측면에서 iOS 에서 사용되는 방식이 무엇인지 설명해주세요.  

- Swift에서는 ARC라는 방식을 이용해서 메모리 참조 카운트를 계산해서 해제하는 방식입니다.

ARC의 원리에 대해서 설명해주세요.  

- 이전에는 가비지 컬렉터를 사용했지만 ARC에서는 컴파일타임에서 프로그램을 실행했을때 레퍼런스 카운트가 변하는 것을 계산하여 메모리를 해제하는 코드를 자동으로 삽입해주는 방식입니다.

ARC를 사용하면서 성능저하를 최소할수 있는 방법은 무엇일까?  

- ARC를 사용하면서 발생할수있는 메모리 문제는 강한참조, 순환참조 문제일 것입니다. 순환참조가 된다면 Reference Count가 0으로 떨어지지 않아 메모리 누수 문제가 발생할 수있고, 이를 해결하기 위해서 weak, unowned라는 키워드를 이용하여 순환참조 문제를 해결할 수있습니다.

weak, unowned의 차이점은 무엇인가요?  

- weak은 옵셔널로 메모리가 해제될 수 있고, Unowned는 메모리에 해제되지 않았다고 보장된 방식입니다.

메모리 누수를 어떻게 찾을 예정인가요?  

- xcode의 메모리 그래프에서 의심되는 영역을 표시해주기 때문에 그 부분을 찾아내고, 순환참조가 일어난 부분에 weak를 적용하는 방식으로 문제를 해결할 것 같습니다.

delegate 패턴을 사용할때 발생할 수 있는 ARC문제, 해결 방법  

- 의도? 순환참조, 델리게이트 패턴을 알고 있는가

민하님은 메모리 누수를 방지하기 위한 민하님만의 해결책이나 스타일이 있나요?  

- 그 부분이 정립되기까지 아직 숙련도가 부족한 것 같고, 대부분의 경우에는 클로저에서 발생을 하는데 다른 클래스 내부에서 참조를 할 때는 확실하게 순환구조가 느껴져서 방지를 했는데, 클로저 같은 경우는 weak self를 쓰는것이 습관이 되어있습니다. 구조체와 클래스를 혼용해서 사용할 경우 문제가 발생하는 것 같습니다. 설계단계에서 구조체 클래스 설계를 확실히 하고, 순환참조 문제가 발생할 것 같다면 다른 모델로 분리하는 선택을 할 것 같습니다.

클로저를 사용할 때 필수적으로 weak self를 한다는 말씀이신가요?  

- 대부분의 경우 쓸 것 같습니다.
- escaping 클로저에 대한 부분이 나왔으면 좋겠다.

## 인예님: CPU 스케줄링

스케쥴링 왜 필요한가?
i/o 바운드 잡은 CPU를 짧게 자주 쓰게 된다. 길게 사용하는 작업이 독점해서 

선점형 스케줄링은 운영체제가 진행중인 작업을 빼앗을 수 있는 스케줄링이다.
단점: 자주 빼앗기게 되면 컨텍스트 스위칭이 자주 발생하여 오버헤드 발생. 작업이 많고 빨리 응답을 해야할 때

시원님 질문: CPU 가 여러 개 있을 때 비대칭 멀티 프로세스 대칭 멀티 프로세스 ... 어떤 방식이 선호 되고 어떤 것이 더 이점이 있는가?

대칭 멀티 프로세스가 더 효율적일 것 같다 그 이유는 다 동등하기 때문에 한 프로세서에게 의존하지 않고 병목 현상이 발생하지 않다. 

`왜 필요한가요?`  
: 효율성과 사용성 측면에서 필요한 것 같다. 우선 CPU를 효율적으로 사용해야한다. 그리고 CPU bound job이 들어가면 I/O bound job이 오래기다려야할 수 있기 때문에 사용자가 불편을 겪을 수 있다.  
-> 피드백: 한정된 자원이라는 키워드가 나오면 좋을 것 같다.`대칭 멀티 프로세싱 vs 비대칭 멀티 프로세싱 중 현대에 사용되는게 주로 어떤건지 알고 계신가요?`  
-> 잘 모릅니다. 하지만 제가 개인적으로 생각했을 때 대칭 멀티 프로세싱이라고 생각합니다. 현대에는 사용자에게 피드백을 빠르게 주는 것이 중요하기 때문에 병목현상을 없애는 것이 최우선 과제라고 생각하기 때문입니다

## 승재님: Swift Concurrency 

#### 동기작업과 비동기 작업에 대해 설명해주시고 각각의 장단점을 설명해주십시오

A. 동기 작업은 작업시간에 맞춰서 시작하는 방식, 비동기는 요청하는 작업의 완료 지점을 따지지 않고 시작한다. 비동기 작업이 성능이 더 좋다. 왜냐하면 I/O 작업같은 경우 시간이 오래 걸리는데 동기작업으로 하게 되면 사용자에게 기다리게 할 수가 있다. 비동기로 하게 되면 동시에 여러 작업을 수행할 수 있기 때문에 빠르다. 

동기로 해야하는 작업? 

앱 같은 경우 가장 상단에서 돌아가는 UI 작업은 동기적으로 실행하는 것이 좋을 것 같다.

현준: Main 스레드에 돌아간다면 비동기 작업으로 해도 되지 않을까?

각각의 비동기 작업으로 보여줘야 하는 데이터가 불일치 할 수 있기 때문에 동기적으로 메인스레드에서 처리하는 것이 더 안전할 것 같다. 

시원질문: 싱글 코어를 사용하는 하드웨어에서 두 함수를 동기적으로 실행할 때, 비동기적으로 실행할 때 소요 시간이 절반정도로 차이가 날지? 궁금하다. 

A. Core 갯수와 스레드 갯수에 관련 있을 것 같다. 하나의 코어당 하나의 스레드가 배정되는데, 하나의 코어에서 두개의 스레드를 처리한다고 해서 절반이 되는 것이 아니라 오히려 컨텍스트 스위칭이 발생해서 절반은 안될 것 같다. 

순차적으로 작업이 진행해야하는 경우 (순서가 중요할 때)는 동기로 작업돼야 할 것 같다. 

시원: 스레드가 많아지면 성능도 좋아지지 않을까? 한 코어당 하나만 작업할 수 있기 때문에 두 함수를 그냥 돌리는거나  비동기적으로 처리하나 다이나믹하게 차이는 없다. 


iOS에서 비동기 작업을 할 때 클로저를 사용하는데 강한참조가 비동기 작업을 할 때 언제 강한 참조를 해줘야하는가?

태스크 내부에서 순환참조가 발생할 수 있는가...? 태스크 내부에서 순환 참조 발생할 수 있다. 비동기로 받아온 이후에 강하게 참조할 것이고, ..... (정신을 잃어버렸다)

#### GCD의 어떠한 문제점을 해결하고자 Swift Concurrency가 도입이 되었는가?
Swift의 특성을 잘 반영하지 못했다. 예전에 나온 object-c의 관례가 남아서 그렇지 Swift의 빠르고 간결하고 안전한 특성을 살리지 못했다. 우선순위 역전 스레드 폭발 등의 문제 를 해결하기 위해 나왔따.

디스패치 큐 안에서 우선순위 큐 두개를 만들고 높은 우선순위에서 먼저 작업이 시작이 되고, 높은 우선순위의 작업이 순ㅇ

인예님 : GCD에서는 우선순위 역전을 해결할 수가 없을까요?

Concurrency에서는 actor + co-routine 방식으로 멈추거나 양보하는 방식
GCD에서는 한 번 작업 시작 하면 멈출 수는 있지만 계층적인 관계에서의 취소는 어렵다. 

시원: 우선순위 큐를 썼으면 더 좋았을텐데 왜 큐를 썼을 까?

현준: 낮은 우선순위를 올려서 해결한다. 작업을 알고 일시 중지 하지 않는 이상 우선순위가 알아서 높아져버리기 때문에 해결할 수 없다. 




- GCD 문제 중 스레드 폭팔에 대해 말씀하셨는데 Concurrency에서는 어떤 방법으로 해결했는지 설명하라
    - 협력 스레드 풀을 만들어 최대한 스레드를 재사용하는 방식으로 작업을 분배
- GCD에서는 작업당 스레드 하나 할당해서 처리한다라 생각하는데 Concurrency에서는 여러 작업을 어떻게 처리 하는가?
    - Continuation 의도


컨티뉴에이션 스위칭이 스레드 스위칭보다 값이 싸다. 
어떻게 스레드 풀에서 관리하는지 



## 건우님:  File System

연속할당과 불연속 할당의 장단점:
File Sytem에서 할당 같은경우에는 파일에 데이터가 블록단위로 저장이 되는데 블록은 쪼개져 있다. 파일은 블록 사이즈와 동일하지 않고 더 큰 경우가 많다. 파일을 쪼개서 블록에 할당을 한다. 연속 할당은 1번 블럭에 할당했으면 1,2,3,4,5번 블록에 연속으로 할당. 불연속 할당은 이리저리 떨어져있다.
연속할당도 1,2,3,4.. 블록이 있다고 해도 3,4번에 A가 저장이 되어있고 B를 저장하려 할 때 1,2번을 저장하고 나머지는 조각화가 일어나서 찾아내야한다. 불연속은 어차피 다 조각이기 때문에 다음 포인터를 저장하는 테이블 갖고 찾아간다. 

현준: 연속으로 하면 캐싱에 엄청 용이하다. 데이터를 블록단위로 가져온다. 그래서 붙어있을 수록 캐싱 효율이 좋다.

인예: 연속, 불연속 할당을 혼합하여 사용도 가능할까?

A. 사용하고자 하면 할 수 있을 것 같다. 

Q. iOS는 어떤 방식을 사용하는가?

A. 현대에서의 파일 시스템은 공개를 안하는 경우가 많다. 
파일 시스템이 시스템의 속도에 가장 큰 영향을 줄 수도 있기 때문에 해당 기술을 공개를 잘 안하는 경우가 많다. 

시간적인 측면, 공간적인 측면을 고려해서 결정하면 좋겠다. 

현준Q. iOS의 애플 파일 시스템에 대해 설명해달라

A. 독자적인 APFS라는 파일시스템을 사용하고 있으며 빠른 스토리지에 최적화가 되어있다. 
특별한 점은 
1. 동일한 데이터를 복사하지 않고 공유를 한다. 
2. 샌드박스 구조를 사용한다

샌드박스 구조란 Apple 은 iOS, MacOS등 다양하게 운영체제가 있는데 특히 iOS환경에서 핵심적인 파일 관리 방식이다. 앱 하나마다 하나의 샌드박스 공간을 할당 받게 된다. 들어오지 못하는 공간을 확보한다. 내 앱과 다른 앱간의 서로 영역 침범을 막을 수 있게 된다. 
컨테이너라는 하위 개념이 존재하는데 번들 컨테이너, 데이터 컨테이너, Icloud 컨테이너
읽기 전용으로 번들 컨테이너에
개발자와 사용자가 접근 가능한 컨테이너는 데이터 컨테이너,
iCloud는 런타임에 개발자가 접근을 허용하여 가져다 쓴다. 

각 앱이 샌드박스 내에서 관리를 하는데, 안전하게 App간에 데이터를 교환하는 방법이 무엇이 있는가?
- 사용자에게 권한은 확실하게 동의 받아야 한다. 받았을 때에 다른 앱은 안되고 기본 앱에 관해서만 권한을 받고나서 애플이 제공하는 메서드를 통해 접근 가능 
- (현준) App Group과 URL을 활용해서 데이터를 주고받을 수 있다. App Extension, Socket 통신을 하거나 같은 프로젝트 안에 있더라도(위젯과 앱 관계) 다른 앱으로 동작한다. 
- (시원) 애플워치 앱이랑 스마트폰 앱간의 공유할 때 App Group을 쓴다. 

하나의 파일에서의 충돌은 사용자가 사용중에 외부에서 전원을 차단한 경우 파일시스템은 이 경우에 유지를 하기 위해서 FSCK.
와리? 임시저장 한다. 
DB에서 A라는 저장 공간 뿐만 아니라 로그공간도 두고 있다. 

소감
- 하길 잘 했다.
- 면접분위기 처럼 하는게 좋을 것 같다.
