# 알고리즘과 코딩테스트

## 코딩테스트?

정말 학문적인 관심에 의해 알고리즘을 공부하고 싶을 수도 있지만 대부분은 코딩테스트를 준비하는 관점에서, 혹은 면접에 대비하기 위함일 것이라 생각합니다. 이부분을 염두하여 설명하도록 하겠습니다. 

## 언어선택, IDE 혹은 테스트 환경

> 지피지기면 백전백승

프로그래머스, 백준, 구름 등 다양한 코딩테스트 환경 존재함  

정답을 제출 하는 방식이 다름. 함수를 넘기는 방식도 있고, 표준 입출력을 다뤄줘야하는 경우도 있음. 예비 테스트 혹은 준비 기간을 줄 때 테스트 해서 익혀놓는 것을 권장함...  

특히 **Swift로 시험을 치르는 경우 일부 환경에서는 강제 언랩핑 warning을 에러로 간주하여 테스트가 안됐던 적도 있음** 이부분 유의. 미리 테스트 해볼 것!

정말 중요한 요소인데, 인터넷 검색이 가능한 테스트인지 IDE활용이 가능한지 등의 조건은 반드시 확인하고 **이에 맞는 전략을 생각해 가야 한다**고 생각합니다...(조금 추하더라도 어쩔 수 없어요)

개인적인 생각으로는 프로그래밍 언어 선택지를 줄 경우에 굳이 Swift를 고집해야하는지 모르겠음. 시간싸움이기 때문에 빠르게 할 수 있는 것 선택하자. (경험상 프로그래머스에서 스위프트가 유독 컴파일이 느렸던 것 같음, 그리고 Optional이나 자동완성에 익숙해진 나머지 메서드 파라미터 이름을 까먹는 경우 빈번 ^-^;;) 

### A4용지 한 장 준비
소소한 부분이지만, 대부분의 코딩테스트에서 A4용지 한 장과 필기도구를 허용해 주는 편입니다. 저는 이것을 반드시 챙겨야 한다고 생각합니다. 말 들어!!!!! 🐎🏋️‍♀️

## 문제 접근 및 풀이 과정

1. 문제 꼼꼼히 읽기
2. 본질이 무엇인지 파악하기(추상화 하기)
3. 큰 문제를 작은 문제로 쪼개기
4. 적절한 자료구조, 알고리즘 적용하여 해결하기

#### 1. 절대로 머리부터 들이 박지 말자. 초기에 방향성을 잡는데 5분만 투자해도 추후 20분 삽질 할 것을 막아낼 수 있음.

잘못된 접근은 불필요한 노가다를 하게 만들거나 심지어는 틀리게 만들어 엎고 처음부터 다시 시작하는 경우도 있었음. 문제를 그대로 바로 풀려고 접근하기보다는 문제를 읽고 해당 문제가 최종적으로 요구하는 것이 무엇일까?를 잘 생각해 보는것이 오히려 더 시간을 아끼는 길이라고 생각함.


#### 2. 수학적으로 해결할 수 있는 문제면 수학적으로 해결하자, 직관력을 키울 수 있도록 다양한 경험들을 해보자(많이 풀자)

> 가로의 길이가 x, 세로의 길이가 y인 모눈종이가 있을 때 해당 모눈 종이의 대각선이 지나가는 모눈의 갯수는 총 몇 개일까?

![image](https://github.com/user-attachments/assets/371c73be-7fd7-4b4f-aabe-89bb487f1f04)


수학으로 예시를 들자면, 1차함수 그래프가 다른 2차 함수 혹은 그 이상의 곡선형 그래프에 **접한다**라는 지문이 있다면 이 부분은 무조건 **중근을 갖는다**로 해석한 후에 풀이를 하는 경우가 많다.  그래서 문제의 지문이 결과적으로 요구하는 것이 무엇인가? 하는 수학적 직관을 키우는게 생각보다 중요하다고 생각함.  
귀납적으로 사고한다 혹은 점화식을 통한 급수 혹은 수열을 값을 묻는 문제라면 기본적으로는 재귀함수를 활용하여 해결해야겠지만, 조금더 수학적으로 해결이 쉽게 해결된다면 바로 결과를 내는 것이 더 빠를 것이다. 
![image](https://github.com/user-attachments/assets/26cd382e-772f-4926-bf01-caa2eaafe3d9)

_(하노이탑 문제를 떠올려보자. 재귀함수 혹은 DP를 통해 최소 옮긴 횟수를 유추 가능하지만, 우리는 이미 직관적으로 `2^n-1`라는 값을 알고있다)_

물론 문제에서 요구하는 것이 수학적인 방법으로 지름길 답안을 내는 것이 아닐 수도 있지만, 시간적 측면에서 압도적으로 빠른 경우들이 있다.



## DP(Dynamic Programing)

<img
  src="https://github.com/user-attachments/assets/4687013f-7cdc-4dc6-99e0-f595ff883f4c"
  width="600"
  alt="DP-example">


동적계획법은 정확히 뭘 하는 것일까. 최적의 해를 찾는 문제 의 경우 나옴.

최적부분구조 라는 말도 있고, 부분해가 전체 해의 어쩌고저쩌고...도 있지만 
제가 생각했을 때 핵심은 다음과 같습니다.

1. 큰 문제의 해결 경로중에 작은 문제의 정답이 경로를 필히 다시 거쳐감.
2. 이 작은 문제의 해를 **저장하여 해결** 그들을 종합하여 큰 문제의 답을 낼 수 있어야 함

큰 문제를 작은 문제로 나눠 해결을 해야한다? 
이러면 바로 DP 써야겠구나 생각하시면 될 것 같습니다.

### 제가 생각하는 유의 포인트

탐욕법(Greedy)문제인지 동적계획법(DP) 문제인지를 빠르게 판단하는 것이 중요하다고 생각합니다. 이게 꽤나 모호하게 나왔다고 느꼈을 때도 종종 있었기 때문입니다. 그리고 둘의 풀이방식은 비슷한 듯 하면서도 꽤나 다르다고 생각하기 때문에.... (제 체감상 Greedy는 DP의 하위호환 같아요) 얌체같이 순간순간 마다 최고를 골라도 문제가 없냐. 혹은 현재 최고의 선택이 추후에 다른 비용을 요구하여 제약이 생기느냐? 이 것을 빠르게 판단하시어 둘 중 하나로 접근을 하시는게 좋을 듯 합니다. 난이도 자체는 탐욕법이 압도적으로 쉽습니다. 

최적의 경로 혹은 피보나치 때문에 가장 인접한 것들이 바로 그다음의 값을 낸다고 생각하는 경우도 많은데, 이 생각에 매몰되면 안됩니다. 다음 답을 만들어내는 값은 바로 그 이전 해가 아닐 수도 있습니다. 

예를 들어 피보나치 수열도 우리가 만들기 나름입니다. 피보나치 수열은 n-2, n-1의 합이 n번째 항을 만들어내지만 초항이 충분이 이미 주어져 있다면 n-4, n-3의 합이 n번째 항을 만들게 할 수도 있습니다. 

### 예시


1. 문제랄 것도 없지만 피보나치 수열 구하기
2. 위의 이미지에 나온 최단경로의 수 구하기
3. 징검다리 문제 (직전에 골랐던 것을 다시 못고른다 + 최적의 값을 내야한다 => DP일 가능성 농후) 
4. **0-1 배낭문제** 이건 그냥 외우는 거 추천
