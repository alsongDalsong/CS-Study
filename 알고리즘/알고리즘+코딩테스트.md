# 알고리즘과 코딩테스트

## 코딩테스트?

정말 학문적인 관심에 의해 알고리즘을 공부하고 싶을 수도 있지만 대부분은 코딩테스트를 준비하는 관점에서, 혹은 면접에 대비하기 위함일 것이라 생각합니다. 이부분을 염두하여 설명하도록 하겠습니다. 

## 언어선택, IDE 혹은 테스트 환경

> 지피지기면 백전백승

프로그래머스, 백준, 구름 등 다양한 코딩테스트 환경 존재함  

정답을 제출 하는 방식이 다름. 함수를 넘기는 방식도 있고, 표준 입출력을 다뤄줘야하는 경우도 있음. 예비 테스트 혹은 준비 기간을 줄 때 테스트 해서 익혀놓는 것을 권장함...  

특히 **Swift로 시험을 치르는 경우 일부 환경에서는 강제 언랩핑 warning을 에러로 간주하여 테스트가 안됐던 적도 있음** 이부분 유의. 미리 테스트 해볼 것!

정말 중요한 요소인데, 인터넷 검색이 가능한 테스트인지 IDE활용이 가능한지 등의 조건은 반드시 확인하고 **이에 맞는 전략을 생각해 가야 한다**고 생각합니다...(조금 추하더라도 어쩔 수 없어요)

개인적인 생각으로는 프로그래밍 언어 선택지를 줄 경우에 굳이 Swift를 고집해야하는지 모르겠음. 시간싸움이기 때문에 빠르게 할 수 있는 것 선택하자. (경험상 프로그래머스에서 스위프트가 유독 컴파일이 느렸던 것 같음, 그리고 Optional이나 자동완성에 익숙해진 나머지 메서드 파라미터 이름을 까먹는 경우 빈번 ^-^;;) 

### A4용지 한 장 준비
소소한 부분이지만, 대부분의 코딩테스트에서 A4용지 한 장과 필기도구를 허용해 주는 편입니다. 저는 이것을 반드시 챙겨야 한다고 생각합니다. 말 들어!!!!! 🐎🏋️‍♀️

## 문제 접근 및 풀이 과정

1. 문제 꼼꼼히 읽기
2. 본질이 무엇인지 파악하기(추상화 하기)
3. 큰 문제를 작은 문제로 쪼개기
4. 적절한 자료구조, 알고리즘 적용하여 해결하기

#### 1. 절대로 머리부터 들이 박지 말자. 초기에 방향성을 잡는데 5분만 투자해도 추후 20분 삽질 할 것을 막아낼 수 있음.

잘못된 접근은 불필요한 노가다를 하게 만들거나 심지어는 틀리게 만들어 엎고 처음부터 다시 시작하는 경우도 있었음. 문제를 그대로 바로 풀려고 접근하기보다는 문제를 읽고 해당 문제가 최종적으로 요구하는 것이 무엇일까?를 잘 생각해 보는것이 오히려 더 시간을 아끼는 길이라고 생각함.


#### 2. 수학적으로 해결할 수 있는 문제면 수학적으로 해결하자, 직관력을 키울 수 있도록 다양한 경험들을 해보자(많이 풀자)

> 가로의 길이가 x, 세로의 길이가 y인 모눈종이가 있을 때 해당 모눈 종이의 대각선이 지나가는 모눈의 갯수는 총 몇 개일까?

![image](https://github.com/user-attachments/assets/371c73be-7fd7-4b4f-aabe-89bb487f1f04)


수학으로 예시를 들자면, 1차함수 그래프가 다른 2차 함수 혹은 그 이상의 곡선형 그래프에 **접한다**라는 지문이 있다면 이 부분은 무조건 **중근을 갖는다**로 해석한 후에 풀이를 하는 경우가 많다.  그래서 문제의 지문이 결과적으로 요구하는 것이 무엇인가? 하는 수학적 직관을 키우는게 생각보다 중요하다고 생각함.  
귀납적으로 사고한다 혹은 점화식을 통한 급수 혹은 수열을 값을 묻는 문제라면 기본적으로는 재귀함수를 활용하여 해결해야겠지만, 조금더 수학적으로 해결이 쉽게 해결된다면 바로 결과를 내는 것이 더 빠를 것이다. 
![image](https://github.com/user-attachments/assets/26cd382e-772f-4926-bf01-caa2eaafe3d9)

_(하노이탑 문제를 떠올려보자. 재귀함수 혹은 DP를 통해 최소 옮긴 횟수를 유추 가능하지만, 우리는 이미 직관적으로 `2^n-1`라는 값을 알고있다)_

물론 문제에서 요구하는 것이 수학적인 방법으로 지름길 답안을 내는 것이 아닐 수도 있지만, 시간적 측면에서 압도적으로 빠른 경우들이 있다.

#### 3. 자료구조를 잘 고르자

2번을 유의하여 중복을 불허한다? => Set, Dictionary를 떠올려야 함.
우선순위 고려사항이 2개 이상이며 정렬을 한다? => tuple + lambda sort ( `.filter{ ~~~ }` )

#### 4. 람다 함수 잘 활용하기, 고차함수 잘 활용하기.

코테에 있어서 람다 함수를 잘 활용하는 것은 정말 엄청난 효율을 내는 것 같습니다. 익숙하지 않다면 작은 함수로 쪼개는 것이 좋긴 한데, 함수로 나눈 다는것이 시간이 촉박한 상황에는 마땅지 않을 수가 있습니다.
또한 고차함수를 적절히 활용하는 것은 실수를 줄이고 확실한 보장이 되는 식을 만들어낼 확률이 높습니다. (시간 복잡도가 정말 중요하다면 남용해서는 안되는 것으로 알고 있습니다. 약간 느림)  
Swift 같은경우에 코테 할 때 nil,옵셔널 처리가 정말 귀찮으므로 compactMap을 적극 활용해 보시는 것도 추천합니다. (어차피 코테에서는 엉망 진창인 에러 유발 값을 인풋으로 주지 않아요) 

#### 5. 외우는 게 가장 좋다. 범재가 천재를 대항할 유일한 방법이자 가장 강력한 수는 외우기.
당연히 이해를 기반으로 하는 것이 가장 좋겠지만, 이해가 안된다면 일단 무작정 외워버리면 나중에 이유는 모르겠지만 술술 튀어나올 수도 있고 오히려 역으로 이해가 되는 경우도 많습니다. 특히 본인이 약하다고 생각하는 알고리즘 같은 경우에는 벼락치기를 해서라도 해당 알고리즘을 외워 가시면 꽤나 큰 도움이 됩니다. 

# 알고리즘 예시 

## DP(Dynamic Programing)

<img
  src="https://github.com/user-attachments/assets/4687013f-7cdc-4dc6-99e0-f595ff883f4c"
  width="600"
  alt="DP-example">


동적계획법은 정확히 뭘 하는 것일까. 최적의 해를 찾는 문제 의 경우 나옴.

최적부분구조 라는 말도 있고, 부분해가 전체 해의 어쩌고저쩌고...도 있지만 
제가 생각했을 때 핵심은 다음과 같습니다.

1. 큰 문제의 해결 경로중에 작은 문제의 정답이 경로를 필히 다시 거쳐감.
2. 이 작은 문제의 해를 **저장하여 해결** 그들을 종합하여 큰 문제의 답을 낼 수 있어야 함

큰 문제를 작은 문제로 나눠 해결을 해야한다? 
이러면 바로 DP 써야겠구나 생각하시면 될 것 같습니다.

### 제가 생각하는 유의 포인트

탐욕법(Greedy)문제인지 동적계획법(DP) 문제인지를 빠르게 판단하는 것이 중요하다고 생각합니다. 이게 꽤나 모호하게 나왔다고 느꼈을 때도 종종 있었기 때문입니다. 그리고 둘의 풀이방식은 비슷한 듯 하면서도 꽤나 다르다고 생각하기 때문에.... (제 체감상 Greedy는 DP의 하위호환 같아요) 얌체같이 순간순간 마다 최고를 골라도 문제가 없냐. 혹은 현재 최고의 선택이 추후에 다른 비용을 요구하여 제약이 생기느냐? 이 것을 빠르게 판단하시어 둘 중 하나로 접근을 하시는게 좋을 듯 합니다. 난이도 자체는 탐욕법이 압도적으로 쉽습니다. 

최적의 경로 혹은 피보나치 때문에 가장 인접한 것들이 바로 그다음의 값을 낸다고 생각하는 경우도 많은데, 이 생각에 매몰되면 안됩니다. 다음 답을 만들어내는 값은 바로 그 이전 해가 아닐 수도 있습니다. 

예를 들어 피보나치 수열도 우리가 만들기 나름입니다. 피보나치 수열은 n-2, n-1의 합이 n번째 항을 만들어내지만 초항이 충분이 이미 주어져 있다면 n-4, n-3의 합이 n번째 항을 만들게 할 수도 있습니다. 

### 예시


1. 문제랄 것도 없지만 피보나치 수열 구하기
2. 위의 이미지에 나온 최단경로의 수 구하기
3. 징검다리 문제 (직전에 골랐던 것을 다시 못고른다 + 최적의 값을 내야한다 => DP일 가능성 농후) 
4. **0-1 배낭문제** 이건 그냥 외우는 거 추천

## Sliding Window

시간복잡도를 따지며 (제한 시간안에 답을 내야한다고 주어질 경우) 한방에 집어 다루는 자료의 크기가 크며 변화하는 자료는 그에 비해 작을 때 !!! 아하!!! 슬라이딩 윈도우!!!


## 이분탐색

시간복잡도를 따지며, 뭔가 문제의 데이터 셋이 수상할 정도로 클 때 (예를들어 `값의 제한 범위는 0<n<1000_000_000 입니다.` 같으면 꽤나 유력) 냄새를 맡아야 함. 이분탐색이구나.

그리고 이분탐색 문제들의 특징은 뇌빼고 풀면 **"엥 너무 쉬운데?"** 하는 생각이 분명히 들고 테스트 돌리면 시간 초과로 _아촤촤~_ 할 겁니다.

이분탐색의 가장 핵심은 mid 값을 잡고 포함하는 부등호를 하느냐 그냥 부등호로 하느냐, 1을 더하느냐 마느냐 등 경계 처리를 잘 해주는것이 핵심입니다.
이를 잘 하지못하면 문제를 잘 풀어놓고 딱 1 차이로 답을 틀리는 경우가 허다하게 발생합니다. 따라서 테스트 케이스를 추가할 수 있다면 안될 것 같은 경우를 빨리 떠올려 경계를 잘 찾아서 답을 내는지가 중요합니다. 어차피 속도 자체는 매우 빠르기 때문에 엣지 케이스를 빠르게 찾아내는게 더 중요할 것 같습니다. 주어지는 테스트케이스만 다 됐다고 나머지까지 안될 경우 허다함. 

## Backtracking 

![image](https://github.com/user-attachments/assets/410a1649-ff83-40a8-94e0-acd7dfd09bd3)

그래프 선택을 딕셔너리로 표기하는 것이 편함

### DFS
- while문 방식, 재귀방식 둘 다 가능
- 재귀가 조금 더 직관적인 느낌이긴 함.
- 핵심은 Stack


### BFS
- DFS가 Stack이라면 BFS는 Queue

## 그 외

### 격자 이동 문제 탐색 문제 나올 경우 8방 혹은 4방 탐색의 식은 따로 만들어 놓는 것이 빠름 

### 시간 애매하면 차라리 이미 풀었던 문제들의 엣지케이스들을 테스트하여 검산 해보아라
일부 코딩테스트의 경우에는 10개정도 테스트케이스를 제공하고 성공여부를 보여주는 경우도 있는데, 이거 다 통과한다고 해서 된다는 보장 없습니다. 안될 것 같은 엣지케이스 혹은 경계의 값들을 잘 생각해내서 완전히 문제의 점수를 가져가는 것이 어차피 못 풀 마지막 문제에 도전하는 것 보다 오히려 나을 수도 있습니다. 

### 함수 분리 할까 말까

### 그래프 표시

1. 딕셔너리
2. 2차원 배열
로 표기할 수 있는데 대부분의 경우에는 1이 유리했음. DFS 에서 한방에 추가 가능...
하지만 경우에 따라 2가 유리한 경우도 있을 수 있음... => 선형대수학적으로 문제를 풀어야 할 경우?


### 그래프 문제... (초고수용)
노드 나온다. 
