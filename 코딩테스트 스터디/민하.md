## 3월 3주차

### Minimum Time to Repair Cars
[문제 링크](https://leetcode.com/problems/minimum-time-to-repair-cars?source=submission-ac)

<details>
    <summary>풀이 및 접근 과정, 피드백</summary>

### 풀이 과정 및 시행착오

### 제출 코드

```swift
class Solution {
    func repairCars(_ ranks: [Int], _ cars: Int) -> Int {
        
        func canRepair(_ time: Int) -> Bool {
            ranks.reduce(0) { $0 + Int(Double(time / $1).squareRoot()) } >= cars
        }
        
        var left = 1
        var right = ranks.min()! * cars * cars
        
        while left < right {
            let mid = (left + right) / 2
            if canRepair(mid) {
                right = mid
            } else {
                left = mid + 1
            }
        }
        
        return left
    }
}
```

</details>


### Koko Eating Bananas
[문제 링크](https://leetcode.com/problems/koko-eating-bananas)

<details>
    <summary>풀이 및 접근 과정, 피드백</summary>

### 풀이 과정 및 시행착오

### 제출 코드

```swift
class Solution {
    func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {
        func canEat(_ eatingSpeed: Double) -> Bool {
            piles.reduce(0) { $0 + ceil(Double($1)/eatingSpeed) } <= Double(h)
        }
        var left = 1
        var right = piles.max()!
        
        while left < right {
            let mid = (left + right) / 2 
            if canEat(Double(mid)) {
                right = mid
            }
            else {
                left = mid + 1
            }
        }
        return left
    }
}
```

</details>


### 3Sum
[문제 링크](https://leetcode.com/problems/3sum/)

<details>
    <summary>풀이 및 접근 과정, 피드백</summary>

### 풀이 과정 및 시행착오

### 제출 코드

#### 망한 코드
```swift
class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        var result: [[Int]] = []
        for i in 0..<nums.count-2 {
            for j in i+1..<nums.count-1 {
                for k in j+1..<nums.count {
                    if nums[i] + nums[j] + nums[k] == 0 {
                        var flag = false
                        for r in result {
                            if r.sorted() == [nums[i],nums[j],nums[k]].sorted(){
                                flag = true
                                break
                            }
                        }
                        if !flag {
                        result.append([nums[i],nums[j],nums[k]])
                        break
                        }
                    }
                }
            }
        }
        return result
    }
}
```

#### 투 포인터 적용

```swift
class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        let sortedNums = nums.sorted()
        var result: [[Int]] = []
        
        for i in 0..<sortedNums.count - 2 {
            if i > 0 && sortedNums[i] == sortedNums[i-1] {
                continue // Skip duplicates for i
            }
            
            var left = i + 1
            var right = sortedNums.count - 1
            
            while left < right {
                let sum = sortedNums[i] + sortedNums[left] + sortedNums[right]
                
                if sum == 0 {
                    result.append([sortedNums[i], sortedNums[left], sortedNums[right]])
                    
                    // Skip duplicates for left and right
                    while left < right && sortedNums[left] == sortedNums[left + 1] {
                        left += 1
                    }
                    while left < right && sortedNums[right] == sortedNums[right - 1] {
                        right -= 1
                    }
                    
                    left += 1
                    right -= 1
                } else if sum < 0 {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }
        
        return result
    }
}

```

</details>

### Longest Substring Without Repeating Characters
[문제 링크](https://leetcode.com/problems/longest-substring-without-repeating-characters)

<details>
    <summary>풀이 및 접근 과정, 피드백</summary>

### 풀이 과정 및 시행착오

### 망한 제출 코드

```swift
class Solution {
    func lengthOfLongestSubstring(_ s: String) -> Int {
        let stringArray = Array(s)
        var length = Set(stringArray).count
        if length == 1 { return length } 

        var left = 0
        var right = 1
        var maxLength = length 
        while right < s.count {
            if isDup(Array(stringArray[left...right])) {
                left += 1
                maxLength = length
            }
            else {
                right += 1
            }
        }
        return maxLength
        func isDup(_ array: [Character]) -> Bool {
            array.count == Set(array).count
        }
    }
}
```

</details>
