## POP의 등장 배경

### 객체 지향 프로그래밍(OOP)의 한계점
#### 1.	단일 상속의 제한: 클래스는 하나의 부모 클래스만 상속받을 수 있어서 여러 기능을 조합하기 어렵다.
기존의 OOP는 동물 -> 포유류 -> 개, 고양이 처럼 상속하는 방식 (이미 특성적인 부분들을 많이 포함하고있음)
POP는 날 수 있는, 걸을 수 있는, 헤엄칠 수 있는 등의 동작으로 정의하고 이들을 조합하는 방식 

#### 2.	상속의 복잡성: 상속이 여러 단계로 이뤄질 경우 이해하기 어려움
#### 3.	참조 타입 중심: POP는 값타입 중심의 패러다임인 반면, 기존의 OOP는 참조타입을 중심으로 하였음
#### 4.	캡슐화의 한계: 상속을 통해 부모 클래스의 구현 세부사항이 노출가능.


### Swift에서 POP가 도입된 이유


#### 1.	값 타입 강화: Swift는 구조체와 열거형 같은 값 타입을 선호. 이러한 값 타입에도 추상화와 다형성을 제공 가능.

##### Composition of Values
- 클래스 구현 상속은 비싸다 (유연하지도 못함)
- 상대적으로 구조체는 저렴하다
- 값 중심value semantics으로 설계하고 결합Composition하는
게 상속하는 것보다 효율적임

#### 2. 유연성 증가: 프로토콜을 통해 다중 상속과 유사한 효과를 얻을 수 있어, 코드의 유연성이 크게 향상됨. -> 높은 단계의 추상화 가능
![image](https://github.com/user-attachments/assets/2acf4545-f7a4-42c3-bea6-ebe485ee54d5)

#### 3.	코드 재사용성: Protocol + Extension 통해 기본 구현을 제공함으로써 코드 중복을 줄이고 재사용성을 높일 수 있음.

#### 4.	테스트 용이성: 프로토콜 기반 설계는 의존성 주입과 Mock 객체 생성을 쉽게 만들어 테스트를 용이하게 함.



### POP의 도입 시기?

<img width="960" alt="image" src="https://github.com/user-attachments/assets/3878a5b8-5213-4443-b70a-917abba0f4d2" />


원래 Object-C 시기에도 Protocol, Category, Extensioin이라는 기능을 제공하여 비슷 한 기능을 했으며
사실 Protocol이라는 개념 자체를 Next, Apple에서 처음 시작한 것이 아니라 기존의 Java에서도 Interface, Abstract Class를 갖고 있었음. (물론 세부적인 차이점이 다소 존재함)


|비교 항목|Swift 프로토콜|Java 인터페이스|Java 추상 클래스|
|--|--|--|--|
|메서드 선언|O (필수 구현 요구)|O (필수 구현 요구)|O (필수 구현 가능)|
|기본 구현 제공|O (extension 사용)|O (default 메서드 사용 가능 - Java 8+)|O (일반 메서드 구현 가능)|
|프로퍼티 (필드) 선언|O (get/set 요구 가능)|X (변수 선언 불가, 상수만 가능)|O (인스턴스 변수 사용 가능)|
|생성자 정의 가능 여부|X (생성자 없음)|X (생성자 없음)|O (생성자 정의 가능)|
|다중 상속 가능 여부|O (여러 프로토콜 채택 가능)|O (다중 인터페이스 구현 가능)|X (단일 상속만 가능)|
|사용 가능 대상|클래스, 구조체, 열거형|클래스만 가능|클래스만 가능|

POP는 2015년 WWDC(세계 개발자 회의)에서 Swift 2.0과 함께 공식적으로 소개됨. 
이때 “Protocol-Oriented Programming in Swift”라는 세션을 통해 Swift는 POP라고 하였다고함. (영상은 삭제된 것으로 보임)

Protocol, Extension은 스위프트 탄생과 함께 하였으나 Protocol의 기본 구현을 제공하는 Extension 기능은 2.0 부터 도입됨.

## 프로토콜 기본 사용

1. 프로퍼티(get,set 지정해야함 Extension에서 기본 return값을 지정할 수도 있음), 메서드 정의 및 요구 가능 (Extension에 기본구현 제공 가능) 
```swift
protocol Sample {
    var a: Int { get }
    func b()
}

extension Sample {
    var a: Int {
        return 10
    }

    func b() {
        print("어쩌구저쩌구")
    }
}
```

## 프로토콜 + 제네릭

### 선언 

associatedtype에 프로토콜 채택하여 제한 가능

```swift
protocol Stack {
    associatedtype Item
    
    func push(item: Item)
    func pop() -> Item
}
```

### 구현 

```swift
struct VStack: Stack {
    typealias Item = Int
    
    func push(item: Item) { }
    func pop() -> Item { ... }
}
```

### 주의점?

- 스위프트 제네릭 방식은 정적인 타입 정보를 전달해서 코드 재사용
- 너무 일반적으로 하면 다른 프로토콜을 또 만들게 될 수도 있거나 거의 의미가 없을 수 있고 너무 구체적으로 프로토콜을 만들게 되면 추상화를 하는 의미가 없으므로 적절한 수준의 추상화를 판단하여 쓸 것 (포괄적인 알고리즘과 타입 가이드 일치 사이에서 균형이 필요함)
- 프로토콜 상속은 어떤 타입을 채택하느냐에 따라 특별한 능력을 제공
- 조건부 채택은 이런 능력들을 조합할 수 있음
- 리스코프 치원 원칙은 모든 클래스에서 작동할 때만 적용하자
- 
## 리스코프 치환원칙

S가 T의 서브 타입일 때, 모든 T 타입 인스턴스는 S 타입 인스턴스로 대체 가능하다
타입을 extension하면 하위 타입도 확장된다
```swift
class Vehicle { … }

class Taxi : Vehicle { ... }

class PoliceCar : Vehicle { ... }

extension Vehicle {
  func drive() { ... }
}

taxi.drive()
```

## POP를 설계할 때의 유의점 

#### 데이터 보다 행동을 먼저 결정하라
프로퍼티 보다는 메서드 들에 유의할 것이며, 내부 안에서 벌어지는 것 보다는 바깥에 어떤 작용을 하는지를 유의할 것 

#### 협력이라는 문맥 안에서 책임을 결정할 것 
클래스를 먼저 생각한 다음에 행동을 생각하고 책임을 분배하기 보다는, 
행동을 통한 어떠한 메시지를 발생할 것이고, 누가 누구에게 전달이 되는지를 정한 뒤에 설계할 것.

#### 설계+ 구현 하며 지속적으로 개선하기 

- 클래스가 하나 이상의 이유로 변경해야 한다면 응집도 낮은 것이다.
변경의 이유를 기준으로 클래스를 분리하라.
- 클래스의 인스턴스를 초기화하는 시점이 아니라, 나중에 서로 다른 속성을 초기화하고 있다면 응집도가 낮은 것이다.
초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
- 메소드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 늦은 것이다.
속성 그룹을 기준으로 클래스를 분리하라.




1. Protocol(메서드 구현) + extension(메서드구현)
2. Protocol(메서드 없음) + extension(메서드구현)
   
