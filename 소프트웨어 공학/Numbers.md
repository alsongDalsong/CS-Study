# #️⃣ 컴퓨터 속 숫자에 대해서

이번 기회에 컴퓨터에서 음수를 표현하는 방법과 소수를 표현하는 방법에 대해서 알아봅시다! 😃

## ➖ 음수를 표현하는 방법

컴퓨터에서 숫자를 어떻게 표현할까요? 모두가 알듯이 이진수로 표헌합니다! 예를들면 숫자 6을 이진수로 나타내봅시다 :) 8비트라고 가정해보겠습니다!

```
6 -> 0000 0110
```

만약 -6 을 이진수로 나타낸다면 어떨까요? 보통 생각할 수 있는 건 마지막 자리수를 부호로 생각하고 1로 바꾸는 방법이 아닐까요?

```
-6 -> 1000 0110 ???
```

하지만 `6 + (-6) = 0` 이 되어야 하는데, 위의 방법으로는 0이 되지 않습니다!

```
  0000 0110
+ 1000 0110
-----------
  1000 1100 ??
```

결국 뺄셈 연산 로직이 필요합니다. 하지만 덧셈 연산만으로 뺄셈을 구현하고 싶었습니다.
여기서 등장한 것이 보수입니다! 보수는 각 자리의 숫자의 합이 어느 일정한 수가 되게 하는 수입니다. 
이 보수를 사용하여 뺄셈을 할 수 있습니다! **10진수**에서 먼저 살펴볼까요?

```
   8
-  6
----
  ??
```

8에서 6을 빼볼까요? 6의 **10의 보수**는 합쳐서 10이 되는 숫자이니 4입니다.

```
   8
+  4
----
  12
```

8에서 4를 더하면 12입니다. 여기서 가장 큰 자리수를 버려주면 2가 됩니다. 이런식으로 뺄셈이 가능합니다!!
그렇다면 2의 보수를 사용하면 뺄셈을 나타낼 수 있습니다! 그렇다면 2의 보수는 어떻게 구할 수 있을까요? 1의 보수에서 1을 더하면 됩니다!

6의 2의 보수를 구해봅시다! 일단 8비트라고 가정하고 6을 2진수로 표현하면 아래와 같습니다.

```
0000 0110
```

6의 이진수의 1의 보수를 구해볼까요? 1의 보수는 합이 1이되는 수입니다. 결국 비트 반전을 하면 됩니다!

```
1111 1001
```

여기서 1을 더하면 6의 이진수의 2의 보수입니다!

```
1111 0110
```

한번 6의 이진수에 이 수를 더해서 0이 나오는지 볼까요?

```
  0000 0110
+ 1111 1010
-----------
1 0000 0000
```

올라간 1을 빼게되면 0이 됩니다!! 와우 신기하네요. 아래처럼 Swift로 어떻게 저장되는지 확인해보실수 있습니다.

```swift
let n = UInt8(bitPattern: -6)

print(String(n, radix: 2)) // 11111010
```

Swift에서는 부호가 있는 정수(Signed Integer)를 Int로 표현하고, 부호가 없는 정수(Unsigned Integer)를 UInt로 표현합니다.

```
print(Int.min)   // -9,223,372,036,854,775,808
print(Int.max)   // 9,223,372,036,854,775,807
print(UInt.min)  // 0
print(UInt.max)  // 18,446,744,073,709,551,615
```

### 💡 -1을 보수로 나타내면 몇일까요?

```
let n = UInt8(bitPattern: -1)

print(String(n, radix: 2))
```

## ⛴️ 소수를 표현하는 방법

그렇다면 소수는 어떻게 나타낼까요?

### 📌 고정 소수점 (Fixed Point)

사실 그냥 그대로 소수점을 나타내면 됩니다. 예를 들면 5.625를 이진수로 나타내볼까요?

```
5.625

정수: 5 (4 + 1) -> 0101
소수: 0.625 (0.5 + 0.125) -> 1010

         정수  소수
5.625 -> 0101 1010
```

이렇게 소수점을 4자리로 하겠습니다. 라고 고정해서 소수를 나타내는 방식을 고정 소수점 표기 형식이라고 합니다. 이렇게 된다면 8비트로는 원래 `-128 ~ 127` 범위를 나타낼 수 있었지만 고정소수점을 사용한다면 `-32 ~ 31`의 범위밖에 표현하지 못하게 됩니다...! 심지어 소수의 경우 충분한 비트가 확보되지 못한다면 거의 소수를 표현하지 못합니다...!

이러한 문제를 해결하기 위해서 부동 소수점이 등장했습니다!

### 🛶 부동 소수점 (Floating Point)

전기전자공학자협회(Institute of Electrical and Electronics Engineers, IEEE)에서 나온 `IEEE 754` 표준에서 부동 소수점 표기 형식을 배포했습니다.
여기서 부동 소수점...? Floating Point...? 부동은 움직이지 않는다는 뜻 같은데, Floating 은 떠다닌다는 뜻인데? 라는 생각을 할 수 있겠지만 부동 소수점의 부동은 浮(뜰 부)를 사용합니다.
실제로 부동 소수점에서 소수점은 고정되어있지 않고 떠다닙니다!

#### 🤔 어떻게...?

32비트에서 최상위 비트는 부호를 표시하고, 8비트는 지수, 나머지 23비트는 가수로 구성되어 있습니다.

```
0 00000000 00000000000000000000000
│ │        │
S Exponent Fraction/Mantissa (23비트)
(1비트) (8비트)
```

위에서 말한 5.625를 표현해보겠습니다. 정수 부분은 `101`, 소수 부분은 `101`이 되겠네요!

```
101 101
```

만약 여기서 정수부분 한자리만 빼고 소수 부분으로 보내버리면 어떻게 될까요? 2자리를 보내버렸으니 아래와 같이 표현할 수 있겠네요.

```
1 01101 * 2^2
```

소수부분을 가수부분에 저장합니다. 나머지 부분은 일단 0으로 채워줍시다.

```
0 00000000 01101000000000000000000
```

여기서 2에 32비트의 Bias 127을 더해 129인 `10000001`를 만들어 이 값을 지수부분에 저장합니다. 짜잔 아래와 같이 5.625를 표현할 수 있습니다.

```
0 10000001 01101000000000000000000
```

실제로 Swift 코드로 Float을 비트로 확인이 가능합니다.

```swift
let n: Float = 5.625
let bitPattern = n.bitPattern
print(String(bitPattern, radix: 2)) // 10000001 01101000000000000000000 (0은 생략 된 모습, 띄어쓰기는 가독성을 위하여 넣었습니다)
```

#### 🤔 잠깐! Bias??

8비트는 -128 ~ 127까지의 수를 나타낼 수 있다고 위에서 알아보았습니다. 이것을 모두 양수로 표현하고자 127을 더했습니다. 앗 그런데 128을 더하지 않은 이유는 뭘까요?
결국 0 ~ 255까지 나타낼 수 있다는 말인데요, 여기서 0과 255는 특수한 경우를 나타내어 1 ~ 244까지를 지수부분으로 사용한다고 합니다.
- 0: 비정규화 수 또는 0을 나타냅니다.
- 255: 무한대 또는 NaN(Not a Number)을 나타냅니다.
결국 -127 ~ 126 까지 표현하느냐 -126 ~ 127 까지 표현하느냐의 문제인데 작은 수보다 큰 수를 다루는 것을 우선시하여 양수 지수 범위를 확장했다고 합니다. 작은 수는 비정규화수로도 가능하기 때문이죠!

#### 🤔 비정규화 수?

위에서 지수가 0인경우 **비정규화 수**로 나타낸다고 했는데요. 정규화 수는 지수가 1 ~ 254 일때 사용되는데요. 암묵적으로 가수부는 1.xxxx... 형식으로 되고 뒤의 xxxx... 부분만 사용하게 됩니다. 따라서 가장 작은 정규화 수는 아래와 같이 나타낼 수 있습니다.

```
0 00000001 00000000000000000000000 -> 1.0 * 2^-126 -> 1.175 * 10^-38
```

비정규화 수로 나타내게 되면 훨씬더 작은 숫자를 나타낼 수 있습니다! 바로 아래와 같이 나타낼 수 있습니다.

```
0 00000000 00000000000000000000001 -> 1 * 2^-23 * 2^-126 -> 1.4 * 10^-45
```

또한 정규화 수에서는 0을 나타낼 수가 없습니다. 왜냐하면 1이 암묵적으로 있기 때문이죠. 하지만 지수가 0인경우 0.xxxx의 형식으로 표현하는 것이기 때문에 0의 정확한 표현이 가능해집니다!

```
0 00000000 00000000000000000000000 -> 0
```

Swift로 Float의 최대 최소를 확인해 볼 수 있습니다. 이제 `leastNormalMagnitude`, `leastNonzeroMagnitude`의 차이점이 보이시나요?

```swift
print(Float.infinity)                  // inf
print(Float.greatestFiniteMagnitude)   // 3.4028235e+38
print(Float.leastNormalMagnitude)      // 1.1754944e-38
print(Float.leastNonzeroMagnitude)     // 1e-45
print(Float.zero)                      // 0.0
```

#### 🤔 잠깐~! 그러면 최댓값, 최소값 범위가 넓은 부동소수점으로 모든 수를 표현하면 되는거 아니야?

잠시만요 Float이 나타낼 수 있는 범위가 Int보다 훨씬 넓고, Int32와 비교해도 훨씬 넓은데 비트도 똑같이 32비트인데 Float만 쓰면 되는거 아니야? 라고 생각하실수도 있겠습니다.

```
print(Int.max)                         // 9223372036854775807 (19자리)
print(Int.min)                         // -9223372036854775808 (19자리)

print(Int32.max)                       // 2147483647 (21억)
print(Int32.min)                       // -2147483648 (-21억)

print(Float.greatestFiniteMagnitude)   // 3.4028235e+38 (39자리)
print(-Float.greatestFiniteMagnitude)  // -3.4028235e+38 (39자리)
print(Float.leastNormalMagnitude)      // 1.1754944e-38
print(Float.leastNonzeroMagnitude)     // 1e-45
```

왜 안되는지 Float의 모양을 살펴봅시다.

```
0 00000000 00000000000000000000000
```

여기서 문제가 드러납니다. 결국 수를 나타내는 부분은 뒤의 가수부분이기 때문에 23자리의 수로 나타낼 수밖에 없습니다. 결국 정확히 표현할수 있는 값은 2^24 = 16,777,216 개의 서로 다른 수를 표현할 수 있습니다.

<img width="500" src="https://github.com/user-attachments/assets/a8fed6d9-34a8-49cc-b468-a115382d8911">

프린트 해보면 이렇게 16777216을 넘어가기 시작하면 정밀도가 팍팍 떨어지기 시작합니다.

```swift
print(Float(16777215)) // 16777215.0
print(Float(16777216)) // 16777216.0
print(Float(16777217)) // 16777216.0
print(Float(16777218)) // 1.6777218e+07
print(Float(16777219)) // 1.677722e+07
print(Float(16777220)) // 1.677722e+07
print(Float(16777221)) // 1.677722e+07
print(Float(16777222)) // 1.6777222e+07
```

지수가 n이라고 생각한다면 인접한 두 수의 간격은 2^n-23 이 됩니다. 결국 지수가 24인 16777216은 2의 단위로만 정확하게 나타낼 수 있게 됩니다. 아래의 33554432는 4의 단위로 정확하게 나타낼 수 있겠죠?

```swift
print(Float(33554432)) // 3.3554432e+07
print(Float(33554433)) // 3.3554432e+07
print(Float(33554434)) // 3.3554432e+07
print(Float(33554435)) // 3.3554436e+07
print(Float(33554436)) // 3.3554436e+07
```

결국 숫자가 커질수록 정확하게 표현하지 못하게 됩니다. 예를 들면 최댓값 근처에서는 간격이 `2^104 -> 2 * 10^31` 이 됩니다.... 하지만 Int의 경우 자릿수만큼 명확하게 표현이 가능하다는 장점이 있습니다.

### 소수는 정확히 표현하지 못할 수 있다.

0.1을 Float으로 나타내게 되면 어떻게 될까요? 

```
정수부분 0
소수부분 00011001100110011001100110011... 무한으로 이어지는 소수부분
```

결국 아래와 같이 나타낼 수 있습니다. 결국 0.1마저도 정확하게 표현할 수 없는 현실...

```
1 10011001100110011001101 * 2^-4 -> 0 01111011 10011001100110011001101 -> 0.10000000149011612
```

```swift
let n: Float = 0.1
print(n) // 0.1 (출력 시 반올림됨)
print(String(format: "%.20f", n)) // 0.10000000149011611938
```

관련된 사건으로 패트리어트 미사일 요격 실패 사고가 있습니다. [링크](https://namu.wiki/w/%ED%8C%A8%ED%8A%B8%EB%A6%AC%EC%96%B4%ED%8A%B8%20%EB%AF%B8%EC%82%AC%EC%9D%BC/%EC%8B%A4%EC%A0%84)

패트리어트 미사일은 0.1초 주기로 시간을 측정하고 있었습니다. 사고 상황에서는 100시간 연속으로 가동되고 있었고, 24비트 부동소수점으로 0.1초를 계산하고 있었다고 합니다. 결국 초당 0.000000095의 오차가 쌓여 결국 0.3433초의 오차를 냈고 687m의 오차로 요격을 실패했고 이는 큰 사고로 이어졌다고 합니다.

이것을 해결하기 위해 나온 방법 중 하나가 Decimal 타입입니다.

<img width="600" src="https://github.com/user-attachments/assets/84d1b9a9-4684-4c5e-ba9f-f084b93bf334">

### Double

Float과 원리는 똑같습니다. 하지만 64비트의 용량을 자랑하고 있고, 부호 1비트, 지수 11비트, 가수 52비트로 표현하고 있습니다. (Bias 1023)

```
print(Double.greatestFiniteMagnitude) // 1.7976931348623157e+308
print(Double.leastNormalMagnitude)    // 2.2250738585072014e-308
print(Double.leastNonzeroMagnitude)   // 5e-324
```
