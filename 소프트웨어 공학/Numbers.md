# #️⃣ 컴퓨터 속 숫자에 대해서

이번 기회에 컴퓨터에서 음수를 표현하는 방법과 소수를 표현하는 방법에 대해서 알아봅시다! 😃

## ➖ 음수를 표현하는 방법

컴퓨터에서 숫자를 어떻게 표현할까요? 모두가 알듯이 이진수로 표헌합니다! 예를들면 숫자 6을 이진수로 나타내봅시다 :) 8비트라고 가정해보겠습니다!

```
6 -> 0000 0110
```

만약 -6 을 이진수로 나타낸다면 어떨까요? 보통 생각할 수 있는 건 마지막 자리수를 부호로 생각하고 1로 바꾸는 방법이 아닐까요?

```
-6 -> 1000 0110 ???
```

하지만 `6 + (-6) = 0` 이 되어야 하는데, 위의 방법으로는 0이 되지 않습니다!

```
  0000 0110
+ 1000 0110
-----------
  1000 1100 ??
```

결국 뺄셈 연산 로직이 필요합니다. 하지만 덧셈 연산만으로 뺄셈을 구현하고 싶었습니다.
여기서 등장한 것이 보수입니다! 보수는 각 자리의 숫자의 합이 어느 일정한 수가 되게 하는 수입니다. 
이 보수를 사용하여 뺄셈을 할 수 있다는 것이 믿어지시나요? **10진수**에서 먼저 살펴볼까요?

```
   8
-  6
----
  ??
```

8에서 6을 빼볼까요? 6의 **10의 보수**는 합쳐서 10이 되는 숫자이니 4입니다.

```
   8
+  4
----
  12
```

8에서 4를 더하면 12입니다. 여기서 가장 큰 자리수를 버려주면 2가 됩니다. 이런식으로 뺄셈이 가능합니다!!
그렇다면 2의 보수를 사용하면 뺄셈을 나타낼 수 있습니다! 그렇다면 2의 보수는 어떻게 구할 수 있을까요? 1의 보수에서 1을 더하면 됩니다!

6의 2의 보수를 구해봅시다! 일단 8비트라고 가정하고 6을 2진수로 표현하면 아래와 같습니다.

```
0000 0110
```

6의 이진수의 1의 보수를 구해볼까요? 1의 보수는 합이 1이되는 수입니다. 결국 비트 반전을 하면 됩니다!

```
1111 1001
```

여기서 1을 더하면 6의 이진수의 2의 보수입니다!

```
1111 0110
```

한번 6의 이진수에 이 수를 더해서 0이 나오는지 볼까요?

```
  0000 0110
+ 1111 1010
-----------
1 0000 0000
```

올라간 1을 빼게되면 0이 됩니다!! 와우 신기하네요.

```swift
let n = UInt8(bitPattern: -6)

print(String(n, radix: 2)) // 11111010
```

## ⛴️ 소수를 표현하는 방법

그렇다면 소수는 어떻게 나타낼까요?

### 📌 고정 소수점 (Fixed Point)

사실 그냥 그대로 소수점을 나타내면 됩니다. 예를 들면 5.625를 이진수로 나타내볼까요?

```
5.625

정수: 5 (4 + 1) -> 0101
소수: 0.625 (0.5 + 0.125) -> 1010

         정수  소수
5.625 -> 0101 1010
```

이렇게 소수점을 4자리로 하겠습니다. 라고 고정해서 소수를 나타내는 방식을 고정 소수점 표기 형식이라고 합니다. 이렇게 된다면 8비트로는 원래 `-128 ~ 127` 범위를 나타낼 수 있었지만 고정소수점을 사용한다면 `-32 ~ 31`의 범위밖에 표현하지 못하게 됩니다...! 심지어 소수의 경우 충분한 비트가 확보되지 못한다면 거의 소수를 표현하지 못합니다 :)

이러한 문제를 해결하기 위해서 부동 소수점이 등장했습니다!

### 🛶 부동 소수점 (Floating Point)

전기전자공학자협회(Institute of Electrical and Electronics Engineers, IEEE)에서 나온 `IEEE 754` 표준에서 부동 소수점 표기 형식을 배포했습니다.

여기서 부동 소수점...? Floating Point...? 부동은 움직이지 않는다는 뜻 같은데, Floating 은 떠다닌다는 뜻인데? 라는 생각을 할 수 있겠지만 부동 소수점의 부동은 浮(뜰 부)를 사용합니다.

실제로 부동 소수점에서 소수점은 고정되어있지 않고 떠다닙니다!

#### 어떻게...?

32비트에서 최상위 비트는 부호를 표시하고, 8비트는 지수, 나머지 23비트는 가수로 구성되어 있습니다.

```
0 00000000 00000000000000000000000
│ │        │
S Exponent Fraction/Mantissa (23비트)
(1비트) (8비트)
```

위에서 말한 5.625를 표현해보겠습니다. 정수 부분은 `101`, 소수 부분은 `101`이 되겠네요!

```
101 101
```

만약 여기서 정수부분 한자리만 빼고 소수 부분으로 보내버리면 어떻게 될까요? 2자리를 보내버렸으니 아래와 같이 표현할 수 있겠네요.

```
1 01101 * 2^2
```

소수부분을 가수부분에 저장합니다. 나머지 부분은 일단 0으로 채워줍시다.

```
0 | 00000000 | 01101000000000000000000
```

여기서 2에 32비트의 Bias 127을 더해 129인 `10000001`를 만들어 이 값을 지수부분에 저장합니다. 짜잔 아래와 같이 5.625를 표현할 수 있습니다.

```
0 | 10000001 | 01101000000000000000000
```

실제로 Swift 코드로 Float을 비트로 확인이 가능합니다.

```swift
let n: Float = 5.625
let bitPattern = n.bitPattern
print(String(bitPattern, radix: 2)) // 10000001 01101000000000000000000 (0은 생략 된 모습, 띄어쓰기는 가독성을 위하여 넣었습니다)
```

#### 잠깐! Bias???

8비트는 -128 ~ 127까지의 수를 나타낼 수 있다고 위에서 알아보았습니다. 이것을 모두 양수로 표현하고자 127을 더했습니다. 앗 그런데 128을 더하지 않은 이유는 뭘까요?
결국 0 ~ 255까지 나타낼 수 있다는 말인데요, 여기서 0과 255는 특수한 경우를 나타내어 1 ~ 244까지를 지수부분으로 사용한다고 합니다.

0의 경우 숫자 0을 나타냅니다. 

Swift로 Float의 최대 최소를 확인해 볼 수 있습니다.

```
print(Float.greatestFiniteMagnitude)   // 3.4028235e+38
print(Float.leastNormalMagnitude)      // 1.1754944e-38
print(Float.leastNonzeroMagnitude)     // 1e-45
print(Float.zero)                      // 0.0
```
