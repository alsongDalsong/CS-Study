# 3월 11일 질의응답

## 민하님: POP

#### Q. Associated Type에 대해 설명해주세요.

A. 추후에 어떤 값이 들어올지 모르지만, 최소한의 범주를 지정해준다. 제네릭을 사용한 자료구조나 프로토콜에서 asso를 선언하고 실제로 구제적인 타입을 넣어서 사용한다.

#### Q. Associated Type을 사용해 본 경험이 있는가?

A. 학습을 위해서가 아닌, 프로젝트에서 필요에 의해 사용해 본 적은 없다.

#### Q. 프로토콜은 동적 디스패치인가 정적 디스패치인가?

A. 대부분 동적을 사용한다 알고있다. 하지만, 익스텐션을 사용하는 경우 일부 정적 디스패치를 사용한다 알고 있다. 익스텐션으로 구체적인 내용이 있을 때에만 정적을 사용한다.

> WWDC를 참고하면, 스위프트는 값타입을 지향하지만 그럼에도 POP인 이유는 그럴 가치가 있기 때문이라고 한다. 추상화를 위해서 그 정도 비용은 낼 가치가 있다고 한다.

> 프로토콜에 선언되어있으면 동적, 프로토콜에 없지만 익스텐션에 구현된게 있으면 정적 디스패치

#### Q. 클래스를 상속하는거랑 프로토콜과 어떤 차이가 있는가?

A. 클래스의 경우 다중 상속을 받을 수 없다. 스위프트가 지향하는 행동으로서 설명하는 구조를 만들기 어렵다. 상속을 받게 되면 불필요한 부분까지 받게되므로 이 점이 프로토콜과 차이가 있다.

> 클래스를 상속받게 되면 세부 구현이 다 노출이 되지만 프로토콜은 피할 수 있다.

#### Q. POP를 실제로 개발에 사용한 경험이 있는가?

A. 직접 POP를 구현하기 보다는, 기존 라이브러리에 있는 내용을 조합해서 새로 설계한 적은 있다. 함수형 프로그래밍에서 연결리스트에서 불변성을 가진 자료구조를 만들고자 했고 필요한 프로토콜을 채택해서 정의하고자 했다.

> 개인적인 견해이지만, 마클에서 테스트 코드에 대해 자주 나온 만큼 Mock 같은 이야기를 하는 건 어땠을까 싶다. + URLProtocol

#### Q. POP의 단점으로 느낀게 있는가?

A. 추상화의 정도를 정하는게 개발자에게 달려있다. 프로토콜은 결국 공통점을 인지하기 위해 추상화 과정이 필요한데, 이게 너무 과하면 프로토콜이 갖는 의미가 유의미하지 않다 생각한다. 적당한 수준의 추상화를 지정하는 것. 이 설계에 어려움이 있는 것 같다. 

#### Q. 어디까지 추상화를 시키는 편인가?

A. 객체들에 대해 최대공약수를 찾는 느낌으로 최대한 크지만 모두가 가지고 있고 추후에 확장가능한지도 고려한다. 

#### Q. 미래까지 고려하는건 오버 엔지니어링이 될 수 있지 않은가?

A. 다시 생각해보면 작게 쪼개는게 좋을 듯 하다. 최소한으로 구분하고 다중 채택이 나을 듯 하다.

#### Q. 다중 채택이 너무 과해질 수 있지 않은가?

A. 나중을 생각하면 다중 채택 비용이 더 적다 생각한다.

> 프로토콜은 수평적인 느낌이라 어떻게 얼만큼 분리할 것인가가 단점이라 생각. 자칫 가독성이 떨어질 수 있다.

> 상속을 하면 부모 메서드도 함께 사용이 가능한데 + 중복 코드 제거, 프로토콜은 매번 다시 정의해줘야 한다.

> 오히려 클래스를 사용할 때 final로 정적 디스패치를 사용하기 편한 느낌이다. 프로토콜은 생각보다 제약이 많은 듯 하다. 너무 쉽게 동적으로 넘어간다.

> 프로토콜은 클래스에 비해 기존에 있던 메서드와 콜라보가 어렵다. 결국 중복이 늘어난다.

> [!NOTE]
> - 간결하게 대답하는 것도 고려하면 좋을 듯 하다. 너무 다음 질문까지 방어하는 느낌.
> - 클래스의 장점이 프로토콜의 단점이 될 수 있다는 사실!
> - 대답이 너무 길어지면 루즈해진다. 짧은 대답으로 면접관과 티키타카를 하는 것도 좋을 듯 하다.
> - 틀린 부분에 대해 면접관과의 대화에서 깨달음 + 수정하는 모습도 어필이 될 수 있다.
> - 생각 관련 질문은 구구절절, 정의는 알잘딱 깔끔하게 딱 대답하기.

## 시원님: 가상메모리

#### Q. 가상메모리를 사용하는 이유는 무엇인가?

A. 이를 사용하면 프로세스 단위로 메모리에 할당을 시키면 프로세스는 크기가 크다보니 메모리의 수가 제한되고 이를 다시 해제할 때 단편화가 발생가능하기에 가상메모리를 사용한다.

> 공유 자원을 효과적으로 사용하기 위해.

> 단편화는 해당 질문에서 조금 깊다 생각. 오히려 가볍지만 확실한 이유, 장점을 말하는게 좋을 듯 함. 단점까지도 말할 수는 있음.

#### Q. 단편화가 너무 많이 일어나서 page fault가 과도하게 일어나는 경우 압축을 많이하는 방법을 고려할 수 있는가?

A. 압축과 가상메모리 모두 공존하여 사용되지만, 압축은 리소스가 크다. 저장 공간을 새롭게 구성해야하기에 리소스가 크기에 최대한 가상메모리를 사용하고 특정한 경우에만 압축을 사용하건 고려할 수 있다.

#### Q. 가상메모리를 사용하는 근본적인 이유보다 불연속할당을 사용하는 이유같은데 이에 대해 설명하라.

A. 프로세스 단위로 메모리에 올리게 되면 프로세스 수가 제한된다. 가상메모리를 사용하면, 현재 읽어지는 일부분만 올릴 수 있기에 더 적은 메모리로 구동이 가능하다.

#### Q. 프로세스 단위로 가상메모리에 올리지는 않는가?

A. 

#### Q. page fault에 다양한 알고리즘이 있는데, valid 상태일 때 사용했다는 사실을 운영체제가 알아야 하는데 페이지 시스템에서 현실적으로 해당 알고리즘이 가능한가?

A. 페이지가 demand 되게 되면 특정 bit로 운영체제가 사용했다는 사실을 파악할 수 있다 생각한다. 왜 운영체제가 알 수 없는지 오히려 궁금하다.

> reference bit 같은 특정 bit는 운영체제가 상태를 알 수 없는 문제를 해결하기 위해 추후에 나온 bit이다. 이와 관련된 알고리즘의 차이? 지식을 알고 있는가 궁금했다.

> bit로 운영체제가 알 수 있는 메커니즘을 아는건 좋다 생각.

#### Q. 쓰레싱이 나타나면 무엇이 안좋은가?

A. 이는 프로세스에 적은 프레임이 할당되어 fault가 빈번하게 발생, 버벅임 즉 쓰레싱이 발생하게 된다. 

#### Q. 어떻게 해결할 수 있는가?

A. 충분한 프레임을 할당해주면 된다. 다만 물리메모리는 무한하지 않기 때문에 Working Set 모델 같은 해결 방법을 적용하면 좋다. 하지만 결국 충분한 공간이 확보되지 못하면 성능이 줄기에 가장 확실한 방법은 메모리 공간을 늘리는 것이다.

#### Q. 비용이 너무 늘어나지 않는가?

A. 서비스의 크기에 따라 하드웨어도 따라와야 한다 생각한다. 트래픽 처리가 많을 경우 당연히 하드웨어도 투자가 되어야한다 생각한다. 또한 소프트웨어로 해결할 수 있는 정도에는 한계가 있기에 비용은 감수해야한다.

#### Q. Paging 기법, Segmentation 기법 등에 대해 알고 있는가?

A. 모른다.

> segmentation은 논리적으로 의미있는 단위로 잘라 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법이다. 

> 딥하긴 한데 Paged segmentation 기법도 있긴 한...

#### Q. Heap을 사용하는 경우와 장단점을 말하시오.

A. 참조객체를 사용할 때 힙에 저장한다 알고있다. 힙은 스텍과 다르게 정렬되어있지 않은 구조이기에 힙의 주소를 스텍에 할당하고 스텍의 주소를 읽어오는 방식으로 동작. 힙은 동적으로 크기를 늘릴 수 있기에 한도가 스텍에 비해 크다. 하지만, 읽고 쓰고가 스텍보다는 비용이 크다.

> 동적 할당 키워드 중요!

***

> [!NOTE]
> - 바로 단점부터 말하기 보다는 점진적으로 가는 것도 고려할 만 하다. 대답의 depth?를 정의(쉬운 내용)부터 점진적으로 단점, 그리고 관련 내용으로 간다면 어떨까?
> - 괜히 너무 딥하게 대답하면 더 깊은 질문이 나올 수 있기에 그 정도를 고려해볼 필요가 있다. 내가 어느정도까지 대답 가능한지 파악하고 전략적으로 대답할 필요가 있다.
> - 학습뿐만 아니라 대답에서도 기본적인 내용부터 챙기기.

## 인예님: 공유자원과 임계구역

#### Q. 실제로 데이터 레이스를 겪은 경험이 있는가?

A. 있다. 네부캠을 진행하는 동안 비동기로 택배가 도착했는지 출력문을 찍는 프로그램을 구현한 경험이 있다. 택배가 언제 도착하는지 모르는 상황에서 이를 해결하려 할 때 경험함.

#### Q. 어떻게 해결했는가?

A. 락으로 두 프로세스 모두 받지 못하는 교착 상태가 발생. 직렬 큐를 구현하여 큐에 먼저 들어간 프로세스가 먼저 자원을 할당하도록 해결.

#### Q. 락을 사용했을 때 교착 외의 문제는 발생하지 않았는가?

A. 페어프로그래밍을 진행, 가독성 측면에서 서로의 락 부분을 파악하기 힘든 문제 발생. 변수로 락을 가지고 있어야하는데 변수명이 확실하지 않으면 락이 어느 시점에서 사용되고 어디서 사용되는지 파악하는데에 시간이 많이 소요됨.

#### Q. 락을 사용하는 상황에서 추가적인 문제가 발생할 수 있다. 그렇다면 이러한 발생가능한 문제를 미연에 방지하는 본인만의 방법이 있는가?

A. 모니터 설계 방식 즉, 객체지향과 연결하여 객체 내부에서 직렬 큐(액터)를 구현하고 객체의 메서드를 통해서만 자원에 접근 가능하도록 구현하는 편이다.

> 액터 사용, GCD 배리어 등을 사용하는 방법을 생각했음.

#### Q. 액터에 대해 설명해달라.

A. 액터는 swift concurrency와 함께 도입됐다. 데이터 레이스를 방지하는 하나의 방법이라 알고 있다. 액터 내부는 비동기 컨텍스트로만 접근 가능하도록 보장.

#### Q. 공유자원을 점유하고 해제하는 과정에서 다음 프로세스에 넘기게 되는데 기다리는 프로세스가 많다면 어떤 정책을 사용하는가?

A. 설계에 따라 다르지만, 세마포어를 사용한다면 먼저 요청한 프로세스에게 넘길 수 있고, 우선순위가 있다면 우선순위에 따라 할당될 듯 하다. 다만 우선순위에서도 낮은 프로세스는 받지 못하는 현상이 발생하기 떄문에 추가적인 처리가 필요하다.

#### Q. 세마포어 외에 또 있는가?

A. 뮤텍스가 있지만 저수준의 방식을 사용할 때 발생하는 문제가 있고 ??

#### Q. 보통 어떤 방식으로 데이터 레이스를 해결하는가?

A. 큐를 만드는 방식이 익숙하지만, 학습 차원에서 액터를 많이 사용하려 노력중이다.

> GCD와 액터를 비교하면 GCD가 더 성능이 좋다고 한다. 꼭 액터만이 아닌 상황에 따라 정하는 것도 좋다.

> 액터로 바꾸고 나니 발생가능한 문제를 미리 알려주기에 좋았음. 다만, 이러한 알림이 확실한가에 대한 의문은 있음.

> [!Note]
> - Good.

## 현준님: 5 계층/ 7 계층

#### Q. iOS에서 네트워크를 처리할 때 사용하는 기술에 대해 설명하라. -> 네트워크 요청을 처리하는 API를 설명하라.

A. URLSession이 있고 이는 네트워크 요청을 처리하는 클래스로 알고 있다. 기본적으로 HTTP요청 응답 처리를 하고, 데이터 파일을 다운로드/ 업로드 기능, 서버와 연결 상태 확인 기능 등을 가지고 있다.

#### Q. 전송계층이 필요한 이유에 대해 설명하라. IP만 알고 있어도 충분하지 않은가?

A. TCP/ IP가 있는데, 데이터 전송에 이러한 계층이 필요하다. TCP의 경우 3-handshaking, 4-handshaking 등으로 전송 흐름을 관리할 수 있고 신뢰성도 보장 가능하다.

#### Q. 전송계층의 또다른 요소인 port Number의 쓰임세에 대해 설명하라.

A. 정확한 대답을 못하겠다.

> IP만으로는 두 호스트가 어떤 애플리케이션을 사용하는지 알 수 없다. 이를 식별하기 위해 사용되며, 공용 IP에 몰리는 사설을 식별하기 위해서도 사용된다.

#### Q. TCP에서 신뢰성 보장이 가능한 이유를 구체적으로 설명하라.

A. 3-handshaking을 통해 연결 여부를 파악할 수 있고, 데이터를 전송할 때에도 그 다음 데이터를 요청하고 받은 후에 다음을 요청하는 등으로 송수신이 이루어지기에 순서에 대한 보장을 받을 수 있다. 또한 신원을 이미 파악했기에 신뢰성 있는 전송이 보장된다.

> 3-handshaking은 신원을 인증하는 단계, 실질적으로 신뢰성을 보장하기 위해서는 오류, 흐름, 혼잡 제어가 사용된다 생각한다.

#### Q. UDP는 TCP와 다르게 비연결형이다. 그럼 UDP에서는 패킷 순서가 보장되지 않았을 때 어떻게 처리되는가? -> 보장되지 않을 때 어떻게 처리할 수 있는가? 예를 들어, 실시간 통화에서 말이 순서대로 도착하지 않으면 문제가 발생가능한데 이러한 한계를 어떻게 극복할 수 있는가?

A. UDP의 경우 다음 순서를 기다리거나 재전송을 하지 않는다. 이로인해 순서가 변경될 가능성이 있는데, 전송하는 쪽에서 신경을 써야할 부분이라 생각한다. 전송에서 순서를 명시해준다면 받는 쪽에서 이를 처리하게 하여 해결할 수 있을 듯 하지만, 특정 기법이 있는지는 모르겠다.

> 실시간 통화에서는 Real Time Transfer라는게 있는데 UDP에 패킷 순서만 추가한 방식이다. 순서가 다르면 폐기, 혹은 버퍼를 통해 정렬 후 전송한다.

#### Q. Network 지연 문제(Latency)를 해결하는 방법에 대해 아는가?

A. 라우터 알고리즘의 최적화 정도 밖에 생각나지 않는다.

> 헤더 커스텀을 생각해보기도 함.

> CDN

#### Q. 헤더로 감싸 보내게 되는데, 각 계층의 헤더들에 대해 설명하라.

A. 간단하게 TCP/IP에서 우선 Data layer의 경우 해당 데이터의 처음과 끝을 구분해주는 헤더를 붙이고 Network에서는 IP 헤더를 붙여 어느 주소로 가야하는지 알려준다. Transport에서는 TCP/UDP로 어떤 방법으로 송수신을 하는지 확인하고, Application에서는 HTTP로 데이터의 목적, 형식, HTTP 버전 정보등을 담는다.

> 헤더의 역할 중요!

> [!Note]
> - Good!
