## **들어가기 전에**

여기서 다루는 스케쥴링은 단기 스케쥴러입니다!

## 왜 필요할까?

먼저 CPU 스케쥴링이 왜 필요한지 간략하게 알아보겠습니다.

프로그램이 시작되면 대부분 CPU burst와 I/O burst가 빈번하게 교차합니다.

![3](https://github.com/user-attachments/assets/6cc6cb20-b844-4a98-a638-0dc46109897e)

하지만 모두 동일한 패턴을 가지지 않습니다.

만약 CPU bound job이 한 번 CPU를 잡고 놓지 않으면 사용자가 불편을 겪을 수 있습니다.

따라서 I/O bound job한테 CPU를 우선적으로 주는 게 필요하다는 것이 CPU 스케쥴링의 필요성입니다.

## CPU 스케쥴링 알고리즘

CPU 스케쥴링 알고리즘은 아래와 같이 다양하게 존재합니다.


| 이름 | 설명 |
| --- | --- |
| FCFS | 비선점형으로 가장 먼저 들어오는 것부터 처리하는 알고리즘 <br> 문제점 <br> 1. 긴 프로세스가 먼저 도착해서 짧은 프로세스들이 다 기다려야 하는 현상이 나타날 수 있음 → Convoy effect 효과 |
| SJF-SRTF | 짧은 실행시간을 가진 프로세스를 먼저 처리하는 알고리즘 <br> 문제점 <br> 1. CPU 사용 시간이 긴 프로세스는 영원히 실행을 못 할 수 있음 → Starvation 현상 <br> 2. CPU burst time을 추정만 할 수 있음 <br> SRTF는 SJF의 선점형 버전으로 더 짧은 프로세스가 들어오면 수행하던 CPU를 뺏음 <br> 큐가 전체적으로 짧아지기 때문에 평균 대기 시간이 짧음. |
| Priority Scheduling | 우선순위가 제일 높은 프로세스에서 CPU를 주는 알고리즘 <br> 기아 현상을 해결하기 위해 Aging기법을 도입함. <br> SJF도 Priority Scheduling 스케쥴링의 일종 |
| RR (Round Robin) | 타임 슬라이스 동안 작업하다가 완료하지 못하면 준비 큐의 맨 뒤로 가는 알고리즘으로 응답시간이 빨라짐. <br> 선점형 알고리즘 중 가장 단순하고 대표적임. <br> *응답시간: CPU를 최초로 얻기까지 걸리는 시간 |
| Multilevel Queue | Ready Queue가 여러개 있고, 본인이 해당한 큐를 절대 벗어날 수 없음. (고정형 우선순위) <br> 전면 프로세스은 타입 슬라이스를 작게 하고, 후면 프로세스는 FCFS 방식으로 처리할 수 있음. <br> 문제점 <br> 1. 가장 높은 우선순위큐에 작업이 계속 존재한다면 그 아래 우선순위 큐로 내려갈 수 없음 |
| Multilevel Feedback Queue | 기본적으로 다단계 큐와 동일한 큐를 가지지만, CPU를 사용한 후 프로세스의 우선순위가 낮아짐. <br> 우선순위가 낮을수록 타임 슬라이스가 높음 → 따라서 마지막 큐는 FCFS 스케쥴링 방식으로 동작함. |

⭐️ 이런 여러 가지 CPU 스케쥴링 알고리즘을 2개로 나눠보면 아래와 같이 나눌 수 있습니다.

- 선점형 (preemptive)
    - 빼앗을 수 있음
    - 대부분의 현대 운영체제가 이 방식을 사용하고 있습니다.
- 비선점형 (non preemptive)
    - 빼앗을 수 없음
 
외에도 Real-Time Scheduling (Soft real-time scheduling, Hard real-time scheduling) 다양한 기법이 있습니다

## Thread Scheduling

스레드는 유저 스레드와 커널 스레드가 있습니다.

그렇기 때문에 스케쥴링하는 방법도 다릅니다.

### Local Scheduling

운영체제 입장에서 생각해 보면 유저 스레드를 알 수 없습니다. 따라서 ‘프로세스’한테 CPU를 줄지 안 줄지만 결정합니다. 이렇게 그 프로세스에 CPU가 갔을 때 프로세스 내부에서 어떤 스레드에게 CPU를 줄지는 결정하는 것이 Local Scheduling입니다.

### Global Scheduling

반면 커널 스레드는 운영체제가 스레드 존재를 알고 있기 때문에 프로세스 스케쥴링하는 것처럼 알고리즘에 근거해서 어떤 스레드에게 CPU를 줄지 결정합니다. 그리고 이를 Global Scheduling이라고 합니다.

또한 각각 경쟁하는 범위가 다릅니다.

### 프로세스 경쟁 범위 - PCS (Process-Contention Scope)

유저 스레드는 하나의 프로세스 내에서 실행되기 때문에 동일한 프로세스 내부의 다른 유저 스레드와 경쟁합니다.

### 시스템 경쟁 범위 - SCS (System-Contention Scope)

SCS는 시스템 수준에서 스레드가 CPU를 얻기 위해 경쟁하는 것을 의미합니다.

## CPU가 여러 개 있을 경우 스케쥴링

프로세서가 여러 개 있을 경우에는 특정 프로세서에만 일이 몰리지 않도록 해야 합니다.

### **대칭 멀티 프로세싱-** Symmetric Multiprocessing(SMP)

모든 프로세서가 동등한 상황입니다. 각 프로세서가 각자 알아서 결정하기 때문에 병목현상을 줄여줍니다.

### **비대칭 멀티 프로세싱 - Asymmetric** M**ultiprocessing(ASMP)**

하나의 프로세서 전체적인 컨트롤을 담당하는 경우입니다.

마치 대장처럼 “너는 일로 가, 너는 저기로 가”하는 것과 같습니다.

오직 하나의 프로세서만 운영체제에 접근하기 때문에 공유와 관련된 문제를 배제할 수 있습니다.

그러나 병목현상이 발생한다는 단점이 있습니다.
