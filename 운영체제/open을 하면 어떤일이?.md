[숲님 학습공유를 먼저 확인해 주세요](https://github.com/alsongDalsong/CS-Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C.md) 

숲님이 올려주신 자료를 보면 파일 시스템과 관련한 시스템 콜이 여러개 있는 것을 볼 수 있습니다.

## Basic System Call 
- open()
- read()
- write()
- etc.

여기서 open이 어떻게 이루어지는지 조금 더 구체적으로 살펴보겠습니다!

# 1. Open

open 시스템콜은 파일의 메타 데이터를 메모리에 올려두는 것을 의미합니다.
공룡책을 보면 크게 몇 개의 중요한 부분이 보이는 것 같습니다.

![open](https://github.com/user-attachments/assets/1170844c-5f26-4826-9876-fe02cdc78cf9)

- 파일을 작업할 때마다 파일 이름을 입력하고 여러 검사를 하는 과정을 줄이기 위해,
- create와 delete를 제외한 모든 작업은 open()을 통해 파일을 열어야한다.
- 열기에 성공하면 open 호출은 file handle을 반환하고 이 핸들은 다른 호출에서 인자로 사용된다.


그러면 이 설명이 무엇인지 살펴보겠습니다!

## 1.1 Open 정의
우선 Open을 한 줄로 설명하면 파일의 메타데이터를 메모리를 올려두는 것입니다.
이 개념을 가지고 예시를 통해 살펴보겠습니다.

## 1.2 create와 delete를 제외한 모든 작업은 open()을 통해 파일을 열어야 한다.

`/a/b` Open한다고 생각해 보겠습니다.

그러면 a는 디렉토리가 되고, 오픈하고 싶은 파일은 b가 됩니다!

사용자 프로그램이 open(/a/b)와 같은 작업을 하게 된다면 시스템 콜이기에 CPU 제어권이 운영체제로 넘어갑니다.

이때 root 디렉토리 같은 중요한 디렉토리의 메타 데이터는 커널에 의해 미리 메모리에 로드되어 있을 가능성이 큽니다.

따라서 root의 메타 데이터를 메모리에 올라가게 됩니다. (open file table)

숲님이 작성해 주신 메타 데이터 설명을 보면 정말 다양한 정보가 있는 걸 알 수 있는데요.

![meta](https://github.com/user-attachments/assets/eef88735-527e-49a0-88d6-bad983682f85)

여기에 위치 정보도 들어있습니다. 따라서 디스크에서 실제 위치를 찾을 수 있게 됩니다.

루트의 메타 데이터를 보고 내용 위치를 찾아가면 디렉토리기이기 때문에 디렉토리 밑에 있는 파일의 메타 데이터가 있게 됩니다.

즉 a의 메타 데이터도 있겠죠? 그렇기 때문에 a를 open(a의 메타 데이터를 메모리에 올릴)할 수 있게 됩니다.

이런식으로 반복하면 결과적으로 b의 메타 데이터까지 메모리에 올라가게 됩니다.

<img width="480" src="https://github.com/user-attachments/assets/5545ab15-316a-4b1c-bc89-a03a6a9338c2">


그럼 아까 공룍책에서 `열기에 성공하면 open 호출은 file handle을 반환하고 이 핸들은 다른 호출에서 인자로 사용된다.`라고 말했던건 어떤 의미일까요?

이 과정까지 거치고 난 뒤에는 무엇을 반환하게 되는 걸까요?

## 1.3 열기에 성공하면 open 호출은 file handle을 반환하고 이 핸들은 다른 호출에서 인자로 사용된다.

위 과정까지 끝나면 b의 메타 데이터까지 메모리에 올라간다고 알아봤습니다. (아직 b의 content는 접근하지 않은 상태)

각 프로세스의 PCB에 프로세스가 open한 파일들에 대한 파일 디스크립터 테이블을 가지고 있습니다. 

<img width="480" src="https://github.com/user-attachments/assets/964b1493-d50b-4051-8f1a-3a87fddb2e23">

이곳에 b의 디스크립터를 추가하고, 이 파일 디스크립터를 반환하게 됩니다.

## 1.4 파일을 작업할 때마다 파일 이름을 입력하고 여러 검사를 하는 과정을 줄이기 위해,

그러면 다음번에 동일한 파일을 쓸 때 다시 파일을 열지 않아도 fd(파일 디스크립터)만 가지고 시스템콜을 할 수 있게 됩니다.

예를 들어 read(fd)를 한다고 하면 운영체제에게 다시 CPU 제어권이 넘어가고, 운영체제는 fd에 대응하는 파일의 메타 데이터 부분을 테이블에서 찾게 됩니다.

그리고 그 파일의 위치 정보를 획득해서 읽게 됩니다.
