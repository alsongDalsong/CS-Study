## **보안이 없는 통신에서 발생할 수 있는 문제**

서버와 클라이언트가 통신할 때 통시 경로상에 있는 네트워크 기기 등을 전부 자기 자신이 소유하고 있는 일은 있을 수 없습니다.

그래서 다음과 같은 문제가 발생할 수 있습니다.

1. 주고받는 데이터를 누군가가 엿볼 수 있습니다.

    ![cs_대지 1-01](https://github.com/user-attachments/assets/085c5fbe-7a9c-454e-b5c0-1684ee87a475)

3. 내가 지금 통신하고 있는 상대방이 내가 진짜 원했던 상대방인지 알 수 없습니다.
  
    ![cs_대지 1-02](https://github.com/user-attachments/assets/73b650a0-4730-4a0f-9f8f-f72c0e64c3ad)

6. 요청의 내용을 변조할 수 있습니다.

이러한 문제를 해결하기 위해 **암호화된 통신이 필요합니다.**

암호화하더라도 데이터가 전송되고 있다는 사실과 암호화된 데이터 자체는 볼 수 있지만,

내용은 해독할 수 없기 때문에 정보가 유출될 위험을 크게 줄일 수 있습니다.

따라서 암호화된 통신을 사용하면 **메시지의 내용을 안전하게 보호할 수 있습니다.**

## 암호화 방식

![cs_대지 1-03](https://github.com/user-attachments/assets/3585557e-dd99-4ad9-9b59-faf1f7f31970)
![cs_대지 1-04](https://github.com/user-attachments/assets/8a2f3814-6987-4034-8709-807a3788415f)

그러면 주고받는 데이터를 암호화해서 누군가 엿보더라도 해석이 어렵게하는 다양한 방법에 대해 알아보겠습니다.

### 대칭키 암호화

서로 같은 키를 가지고 암호화와 복호화하는 알고리즘입니다.

![cs_대지 1-05](https://github.com/user-attachments/assets/4746b0d2-a5aa-4dca-b5b3-82296638bcc4)

이렇게 서로 같은 키를 대칭으로 양쪽이 똑같이 가지고 있다면 중간에 누군가 엿봐도 메시지 내용이 유출될 걱정이 줄어듭니다.
| 암호화 | 복호화 |
| -- | -- |
| ![cs_대지 1-06](https://github.com/user-attachments/assets/a42f3b17-7a5a-4c6d-a170-9701559fe4de) | ![cs_대지 1-07](https://github.com/user-attachments/assets/34948879-2159-40a7-9bd5-887a00f1f75b) |

키는 보통 랜덤한 값으로 구성되며 일정한 길이를 가지고 있습니다.

하지만 서로 사용하는 동일한 키를 어떻게 전달할 수 있을까요?

![cs_대지 1-08](https://github.com/user-attachments/assets/51acac82-b700-4a6c-a8db-52f77db446ba)

만약 키 자체를 전송한다면 중간에 누군가가 이걸 엿보게 되고 결국엔 해당키로 암호화, 복호화하는 것이 의미가 없어집니다.

이것이 대칭키의 주요한 한계점입니다. 키를 가지고 있다면 누구라도 암호를 풀 수가 있게 되는 것이죠.

이 문제를 해결하기 위해 등장한 것이 비대칭키 암호화방식입니다.

### 비대칭키 암호화

비대칭키 암호화는 한 쌍(pair) 즉, 서로 다른 두 개의 키를 사용합니다.

두 개의 키가 서로 다르기 때문에 ‘비대칭키’라고 불립니다.

한 개는 개인키, 비밀키라고 불리는 private key고 또 다른 하나는 공개키라고 불리는 public key입니다.

메시지를 보내는 쪽이 공개키를 사용해서 암호화합니다.

- **공개 키(Public Key)**: 누구나 접근할 수 있으며 데이터를 암호화하는 데 사용됨.
  - 공개키로 암호화하면 개인키로만 복호화가능
- **개인 키(Private Key)**: 본인만 알고 있어야 하며 데이터를 복호화하는 데 사용됨.
  - 개인키로 암호화하면 공개키로만 복호화가능

그리고 암호화된 정보를 받은 상대는 자신의 비밀키를 사용해서 복호화를 진행합니다.

![cs_대지 1-09](https://github.com/user-attachments/assets/e0614072-116c-4bbf-bf51-861a5b06a4ab)

따라서 중간에 누군가가 공개키를 가지고 엿보려고 해도 복호화를 할 수 없으므로 암호문을 풀어서 볼 수 없습니다.

비밀키는 절대 공유하지 않기 때문에 중간에 누군가가 키를 엿볼 수 없습니다.

> 그러면 공개키로 비밀키를 유추할 수 있는 거 아닌가? 라는 의구심이 들었습니다.
> 
> 그래서 좀 찾아보니 현재로써는 극도로 어려운 문제(수학 문제)이기 때문에 쉽지 않다고 하네요.

## 하이브리드 방식

비대칭키가 등장하면서 모든게 잘 해결된 것처럼 보이지만 사실 비대칭키는 속도가 느리다는 한계가 있습니다. 그래서 TLS와 같은 실제 보안 프로토콜은 대칭키 방식과 비대칭키 방식의 장점을 모두 잘 살릴 수 있도록 각각의 방식을 조합해서 통신합니다.

비대칭 키 암호화를 이용해 안전하게 대칭 키를 교환한 뒤, 대칭 키로 데이터를 암호화하는 하이브리드 방식입니다.

1. 처음에 🔑공개키 암호를 사용하여 🔑대칭키(공통키)를 안전하게 교환합니다.
2. 그러면 서버는 자신의 🗝️개인키를 사용해서 복호화하게 되고 대칭키를 알 수 있게 됩니다.
3. 이후부터는 대칭키 암호화를 사용하여 빠르게 데이터를 통신할 수 있습니다.

HTTPS는 이러한 하이브리드 방식을 사용하고 있습니다.


## 증명서

이렇게 첫 번째 문제는 해결이 되었습니다. 이제 두 번째 문제에 대한 해결 방법을 알아보겠습니다.

![cs_대지 1-10](https://github.com/user-attachments/assets/351fd28b-7e79-46ac-8e98-e071047ccd48)

공개키가 진짜 내가 원했던 서버에서 발행한 공개키인지 어떻게 증명할 수 있을까요?

서버가 공개키를 줄 때 누군가가 공개키를 바꿔치기했다면 클라이언트 입장에서는 알 수가 없습니다.

따라서 이를 인증해 주는 공인된 인증기관인 CA가 존재하고, 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다. 여기서 인증기관이란 클라이언트와 서버가 모두 신뢰하는 제 3자 기관을 의미합니다.

1. 서버는 공개키와 사이트 정보를 인증기관(CA)에 등록(제출)한다.
   
  ![cs_대지 1-11](https://github.com/user-attachments/assets/968e964e-e279-43d6-958f-9d9a4e2dc294)

2. 인증기관은 제출된 정보를 검증한다.

3. 검증이 성공적이면 자신의 🗝️개인키로 서버의 🔑공개키에 디지털 서명을 한다.
    1. CA는 서버의 공개키와 도메인 정보를 포함한 인증서를 생성하고
    2. 이 인증서에 CA의 개인키를 사용해서 디지털 서명을 한다.

4. 인증기관은 서버에게 인증서를 발급한다.
    1. 이렇게 하면 인증서에는 서버의 공개키와 CA의 서명이 포함되게 된다.
  
— 사용자가 사이트 접속을 요청 — 

1. 서버는 클라이언트에게 CA의 디지털 서명이 포함된 인증서를 보낸다.

  ![cs_대지 1-12](https://github.com/user-attachments/assets/39d45bc0-8904-4acf-babc-bed91a810ba9)

2. 클라이언트는 인증서의 디지털 서명을 인증 기관의 공개 키로 검증한다.
    1. 이때 인증기관의 공개 키는 사전에 브라우저에 내장되어 있다.
    2. CA의 🗝️개인키로 암호화가 되어있기 때문에 브라우저에 내장된 CA의 🔑공개키로 복호화가 가능하다.

3. 인증서가 복호화에 성공한다면 인증서 안에 있는 서버의 공개키를 알 수 있게 된다.

4. 이후에는 하이브리드 방식으로 통신을 진행한다.


![다운로드](https://github.com/user-attachments/assets/6ba22bf8-af2e-49c3-8629-5b7cb762fc4c)

## SSL와 TLS

지금까지 알아본 내용의 방식을 사용하는 것이 바로 SSL/TLS입니다. 

1. 인증
    1. 서버가 신뢰할 수 있는 대상인지 CA가 발급한 인증서를 통해 검증합니다.
2. 암호화
    1. 하이브리드 방식을 사용해서 중간에 데이터를 가로채거나 조작하지 못하도록 암호화합니다.
3. 무결성
    1. MAC등을 사용해서 무결성을 보장합니다.

SSL/TLS는 클라이언트와 서버 간에 데이터의 무결성과 기밀성을 보장할 수 있는 프로토콜로 SSL는 TLS의 바로 이전 버전입니다. Netscape가 더 이상 개발에 참여하지 않게 되면서 이름이 TLS로 바뀌었습니다. 그래서 SSL의 최종 버전인 3.0버전과 TLS의 첫 버전의 차이는 크지 않으며 소유권을 변경하기 위해서 이름을 변경한 것입니다.

SSL/TLS는 핸드쉐이크 과정을 정리해 보겠습니다.

1. 클라이언트: 클라이언트가 메세지를 송신하며 SSL 통신을 시작합니다. 메시지에는 클라리언트가 제공하는 SSL/TLS 버전을 지정하고, Cipher Suite(암호 스위트)로 불리는 리스트 등이 포함되어 있습니다.
(Cipher Suite는 사용하는 보안 알고리즘 등을 의미합니다)
2. 서버: 서버가 SSL/TLS 통신이 가능한 경우 SSL/TLS 버전과 선택한 Cipher Suites 등을 전달합니다.
3. 서버: 서버가 인증서가 포함된 메시지를 송신합니다. 이때 인증서가 CA에서 발급한 인증서입니다. 클라이언트는 이 패킷을 통해 서버를 인증할 수 있습니다.
4. 서버: 서버가 Server Hello Done메시지를 보내며 최초의 SSL 네고시에이션 부분이 끝났음을 알립니다. 
5. 클라이언트: 인증서가 무결한지 검증되었으면 대칭키를 생성하고, 서버의 공개 키로 암호화하여 서버로 전송한다.
6. 클아이언트: Chnage Cipher Spec 메시지를 송신하여 이 메시지 이후 통신은 대칭키(세션키)를 사용해서 진행한다는 것을 알립니다.
7. 클라이언트: Finished 메시지를 송신합니다.
8. 서버: 이후 서버에서도 마찬가지로 Chnage Cipher Spec → Finished메시지를 송신합니다.
9. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속이 확립됩니다.

## HTTPS

HTTPS는 HTTP 위에 SSL/TLS 계층을 추가한 것일 뿐, 새로운 애플리케이션 계층의 프로토콜은 아닙니다. 즉 HTTP가 평문으로 데이터를 주고받았다면 HTTPS는 암호화를 통해 데이터를 보호하게 됩니다.

HTTP는 직접 전송계층과 소통을 했지만 SSL을 사용한다면 SSL과 통신을 해야 하고, SSL이 전송계층과 소통합니다.

### 그럼 무조건 HTTPS가 좋은 걸까?

SSL을 사용하면 리소스를 다량으로 소비하기 때문에 처리가 늦어지게 된다는 단점이 있습니다.

HTTP의 요청/응답 외에도 SSL에 필요한 통신이 추가되기 때문에 전체적으로 처리해야 할 통신이 증가하게 됩니다. 또 암호화 또는 복호화해야하기 때문에 리소스를 소비하게 되어 HTTP에 비해 부담이 커질 수밖에 없습니다. 그래서 SSL 가속기(엑셀레이터)라는 하드웨어를 사용해서 이 문제를 해결하기도 합니다. SSL의 처리를 SSL 가속기에 맡김으로써 소프트웨어로 SSL을 처리할 때보다 몇 배 빠른 계산을 할 수 있습니다.

또한 CA에서 증명서 구입 등의 비용적인 문제가 부담되어서 HTTP를 선택하는 경우도 있습니다.

## 기타 궁금한 내용 찾아본 내용

**CA가 잘못되는 경우는 없을까?라는 점이 궁금해서 찾아봤습니다.**

확인해 보니 2011년에 네덜란드의 DigiNotar라는 CA기관의 내부 시스템이 해킹당해서 531개 이상의 가짜 증명서가 발행된 적이 있습니다. 이때 구글, 야후, 마이크로소프트와 같은 주요 웹사이트가 포함되어 있었기 때문에 SSL의 근본이 흔들렸다고 합니다.

> There is not any hardware or software in this world exists which could stop my heavy attacks, my brain or my skills or my will or my expertise. (중략) I will sacrifice my soul for my leader.
> 
> 나의 강력한 공격, 나의 두뇌, 나의 기술, 나의 의지, 나의 전문 지식을 막을 수 있는 하드웨어나 소프트웨어는 이 세상에 존재하지 않습니다. (중략) 나는 나의 리더를 위해 내 영혼을 바칠 것이다.


결과적으로 DigiNotar는 신뢰성을 잃고 완전히 파산했다고 합니다. 증명서 무효화같은 대책이 있긴 했지만 효과를 발휘할 때까지 시간이 소요되었기 때문에 그 기간에도 유저가 고스란히 피해를 입었다고 합니다.

**그러면 어떻게 막을 수 있을까요?**

이 사건으로 인해 구글과 같은 다양한 브라우저랑 정부 기관들이 CA를 더욱 엄격하게 평가하게 되었다고 합니다.  그리고 신뢰할 수 없는 CA는 빠르게 제거되었습니다. 

또 많은 웹사이트에서 공개 키 고정(PKP)를 사용하게 되었습니다. 구체적으로 구글은 Chrome이 구글의 CA에서 발급된 인증서만 허용하도록 강제해서 위장할 수 없도록 원천 차단했습니다.

하지만 이 방법 역시 단점이 있었는데요.

만약 어떤 웹사이트가 특정 CA의 인증서를 신뢰하도록 고정했는데, 그 CA가 폐업하게 된다면 해당 웹사이트는 접속이 더 이상 불가능해집니다. 즉 사이트 자체가 먹통이 되어버리는 문제가 발생하게 되는 것이죠. 또 PKP는 특정 CA를 강제하는 기술이기 때문에 한 번 잘못 설정하게 된다면 쉽게 되돌릴 수 없다고 합니다. 이 되돌리는 과정이 매우 번거롭고 복잡하다고 하네요.

## 참고 자료 및 출처

[AWS 강의실 유튜브 영상](https://www.youtube.com/watch?v=VvacoRwYGZc)

[얄팍한 코딩사전](https://www.youtube.com/watch?v=H6lpFRpyl14)

[DigiNotar](https://www.youtube.com/watch?v=eM7l8wXarHI)

기타 관련 책들..
