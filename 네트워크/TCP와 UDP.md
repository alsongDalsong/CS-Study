# 배경 개념
## 인터넷 프로토콜 스택의 4 계층
TCP/UDP를 이해하기 위해서는 인터넷 프로토콜 스택 계층이 어떠한 구조를 가지고 있는지 먼저 이해할 필요가 있습니다.

1. 애플리케이션 계층 (HTTP, SMTP, FTP, Telnet)
   : 메일, 게임, 채팅 프로그램 등 사용자가 실질적으로 접하게 되는 TCP/UDP 기반 응용 프로그램을 만들 때 사용하는 표준 인터페이스를 제공합니다. 
3. 전송 계층 (TCP, UDP)
   : IP 주소에 포트를 더해 전달되는 패킷의 오류와 재전송 등 '신뢰성'을 갖게 만들게 해주거나 (TCP), 비신뢰성이지만 더 빠른 속도로 전달하게 합니다. (UDP)
5. 인터넷 계층 (IP)
   : 패킷을 목적지까지 효율적으로 전달하는 것을 고려합니다. (라우팅)
7. 네트워크 인터페이스 계층
   : 비트 단위의 물리적인 TCP/IP 패킷의 전달과 수신 과정에 대한 부분을 담당합니다.

![image](https://github.com/user-attachments/assets/8638e3cb-d370-46e8-9fb4-cd8c3a3fea97)

## PORT
애플리케이션의 통신을 위해 할당된 숫자입니다. 네트워크에서는 이 포트 번호를 사용하여 데이터를 특정 서비스나 애플리케이션으로 라우팅하고 식별하게 됩니다. 포트번호는 16 비트의 숫자로 0 - 65,535 까지의 범위를 아우릅니다.

![image](https://github.com/user-attachments/assets/a063a620-cff3-404c-b42b-5c09d39f09e6)

## 패킷
패킷은 작은 데이터 조각으로, 네트워크를 통해 데이터를 안전하게 전성하는데 사용됩니다.

![image](https://github.com/user-attachments/assets/3dc828ff-a3d5-47f6-8491-1eb83d2dfee8)

# TCP와 UDP의 기초 개념 및 특징
## TCP (Transmission Control Protocol): 전송 제어 프로토콜
TCP는 연결 지향형 프로토콜로, 데이터의 신뢰성과 순서를 보장합니다. 데이터 전송 전에 송신자와 수신자 간에 연결을 설정하고, 데이터의 정확한 전달을 위해 흐름 제어, 오류 제어, 혼잡 제어 등의 메커니즘을 제공합니다.

특징:

- 연결 지향적: 연결형 서비스로 가상 회선 방식을 제공합니다. 3-way 핸드셰이킹을 통해 연결을 설정하고, 4-way 핸드셰이킹을 통해 연결을 해제합니다.
- 신뢰성 보장: 데이터의 전송 순서를 보장하며, 손실된 패킷은 재전송합니다.
- 흐름 제어 및 혼잡 제어: 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하고, 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지하여 네트워크 혼잡을 완화합니다.
- 속도: 여러 제어 메커니즘으로 인해 UDP보다 전송 속도가 느릴 수 있습니다.
- 방식: 전이중(Full-Duplex), 점대점(point to point)

> - 전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
> - 점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.

### TCP 연결 과정 (3-way handshake)
TCP에서 데이터 전송을 하기 전에 상대방 PC가 받을 수 있는 상태인지 확인하는 과정입니다. 즉, 발신지와 수신지 사이에 논리적인 접속(세션)을 성립하는 과정을 의미합니다.

1. 클라이언트가 서버에 SYN 전송, SYN_SENT 상태로 대기 (접속 요청)
2. 서버가 응답 가능한 상태에서 SYN-RECEIVED 상태로 바꾸고 SYN + ACK를 클라이언트에게 전달 (접속 요청, 접속 수락)
3. 클라이언트가 ESTABLISHED 상태로 변경하고 서버에게 ACK 전송, 이후 ACK를 받은 서버도 ESTABLISHED 상태로 변경 (접속 수락)

> - SYN(synchronize sequence numbers) - 연결 확인을 보내는 무작위의 숫자 값 (내 말 들려?)
> - ACK(acknowledgements) - Client 혹은 Server로부터 받은 SYN에 1을 더해 SYN을 잘 받았다는 ACK (잘 들려!)

![image](https://github.com/user-attachments/assets/664a9dc0-da6b-4fe5-ab29-c1194606b596)

위 과정 이후 패킷을 전송하게 되는데, 서버와 클라이언트가 실질적으로 연결된 것이 아닌 가상으로 연결된 것입니다. (서버 - 클라이언트 사이에 수많은 노드가 존재)

### TCP 연결 해제 과정 (4-way hanshake)

1. Close를 실행한 클라이언트가 FIN 전송, 전송 후 FIN-WAIT-1 상태로 대기
2. 서버는 CLOSE-WAIT으로 상태를 변경하고 응답 ACK 전달 (동시에 해당 포트에 연결되어 있는 서버 애플리케이션에게 close 요청)
3. ACK를 받은 클라이언트는 FIN-WAIT-2로 상태 변경 (서버로 부터 close 요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 FIN을 클라이언트에 보내고 LAST_ACK 상태로 변경)
4. FIN을 받은 클라이언트는 ACK를 서버에 다시 전송하고 TIME-WAIT로 상태 변경 (일정 시간 MSL TIme이 지나면 CLOSE 되고 ACK를 받은 서버도 포트를 CLOSED로 변경)

> TIME-WAIT : 먼저 연결을 끊는 쪽에서 생성되는 소켓으로, 혹시 모를 전송 실패에 대비하기 위해 존재하는 소켓이며,
TIME-WAIT이 없다면, 패킷의 손실이 발생하거나 통신자 간 연결 해제가 제대로 되지 않을 수 있다.

![image](https://github.com/user-attachments/assets/0efbfda7-3701-45e5-945d-074029bd19c7)

## UDP (User Datagram Protocol): 사용자 데이터그램 프로토콜
UDP는 비연결형 프로토콜로, 데이터그램 방식을 사용하여 빠른 데이터 전송을 지향합니다. 연결 설정 과정이 없으며, 데이터의 신뢰성이나 순서를 보장하지 않습니다. IP와 거의 같으나 오류제어(체크섬), 포트만 추가된 형태입니다.

> 연결을 위해 할당되는 논리적 경로가 없고, 각각의 패킷은 다른 경로로 전송되며 독립적인 관계를 지닙니다.

![image](https://github.com/user-attachments/assets/fdfe67b7-7d3d-4081-9829-c9ef7165fa3a)

특징:

- 비연결형 서비스: 연결 설정 없이 데이터를 전송합니다.
- 신뢰성 미보장: 데이터 전송의 성공 여부를 확인하지 않으며, 패킷 손실 시 재전송을 하지 않습니다. (단, 간단한 오류 검사(체크섬)으로 데이터 전송 시 오류를 감지)
- 데이터 전송 순서 미보장: 패킷이 전송된 순서대로 도착한다는 보장이 없습니다.
- 속도: 제어 메커니즘이 없으므로 TCP보다 전송 속도가 빠릅니다.
- 방식: Multiplexing / Demultiplexing

> Multiplexing / Demultiplexing : 하나의 장치에서 여러 애플리케이션이 동시에 네트워크를 사용할 수 있도록 포트 번호를 통해 데이터를 구분 (1:1 & 1:N & N:N)
> 체크섬은 데이터를 전송하기 전과 받은 후에 데이터에 대해 두 번 수행되는 계산입니다. 결과가 다른 경우 전송 중에 데이터가 손상되었음을 의미합니다.
>
> ![image](https://github.com/user-attachments/assets/496cbf3f-f08d-4780-8468-fe3891d417da)
>
> - 1의 보수 덧셈
>
> 16-bit field들에 대해서 덧셈을 수행한다. 각 field들의 덧셈마다 carry bit가 발생할 수 있다.
> carry bit을 sum의 결과의 맨 LSB에 더해준다. (wraparound)
> sum에 대해 반전을 수행한다.
> 이렇게 checksum을 계산할 수 있다.
>
> - receiver 쪽에서 확인하는 방법
>
> sender쪽에서와 마찬가지로 위 2번까지 수행한다.
> 결과를 반전하는 대신, sender쪽에서 계산한 checksum과 OR bit-wise 연산을 수행한다.
> 만약 모든 bit가 1이라면 Error가 없다는 뜻이다.
> 이것이 UDP에서 수행하는 error check 방식이다.

## TCP vs UDP

![image](https://github.com/user-attachments/assets/9a6574ce-ce6b-4ad0-81c6-370047ed3b10)

![image](https://github.com/user-attachments/assets/2eb36c71-9b07-4e01-b4a6-e0504161fa7d)

1. UDP는 TCP 보다 빠르며 서버와의 거리가 멀어질 수록 그 차이가 더 커집니다.
   - TCP는 오류가 확인된 스트림으로 순서대로 데이터 패킷을 전달하기 때문에 올바르지 않거나 누락된 데이터는 재요청을 보내는 지연이 발생합니다.
   - 반면, UDP 패킷의 헤더는 더 작기 때문에 각 연결당 부하(payload)가 더 많이 허용되어 데이터 처리량이 증가합니다.
2. TCP는 UDP보다 데이터 소비량이 많습니다.
   - TCP는 각 데이터 패킷의 헤더에 더 많은 정보를 포함하기 때문에 UDP 보다 더 많은 데이터를 사용합니다.
   - 또한, TCP의 경우 handshake를 통해 더 많은 통신이 이루어지기 때문입니다.
3. TCP는 UDP보다 조금 더 안전합니다.
   - TCP와 UDP는 보안을 목적으로 설계되지 않았습니다. 인터넷을 통해 데이터 패킷을 보낼 뿐입니다.
   - 일반적으로 다른 상위 프로토콜이나 애플리케이션이 보안을 담당하는데, 그럼에도 불구하고 TCP는 패킷의 순서가 지정되고 승인되기 때문에 해커가 악성 데이터를 심기 더 어렵습니다.
4. TCP는 UDP 보다 더 신뢰할 수 있습니다.
   - 마찬가지로 handshake로 전송 플로우를 컨트롤 하는 TCP가 패킷이 전송 과정에서 삭제될 가능성이 훨씬 적습니다.
   - 또한, TCP의 수신자는 들어오는 패킷을 수락하는데 필요한 버퍼 공간의 사용 가능성을 함께 전달하기 때문에 수신량이 초과하는 것을 방지할 수 있습니다. (초과 시 수신자의 가능성 피드백을 기다려야 함)
   - UDP는 초과된 패킷을 기다리지 않고 삭제합니다.
5. UDP와 달리 TCP는 멀티 캐스트를 지원하지 않습니다.
   - TCP는 일대일 연결을 설정하기 때문에 일대다 통신 모델에는 적합하지 않습니다.
   - 반면 UDP는 수신자를 파악할 필요가 없기 때문에 멀티캐스트와 호환됩니다.

### TCP의 주요 활용 사례
TCP는 신뢰성이 중요한 애플리케이션에 적합합니다.

- HTTP / HTTPS (웹 브라우징)
  - 웹페이지를 안정적으로 로드하기 위해 신뢰성이 필요함.
  - TCP를 사용하여 패킷 손실 없이 순서대로 데이터 전송.
- FTP (File Transfer Protocol)
  - 파일이 손상 없이 전송되도록 신뢰성을 보장.
- 이메일 전송 (SMTP, IMAP, POP3)
  - 이메일 데이터를 안전하게 전달하기 위해 TCP 사용.

### UDP의 주요 활용 사례
UDP는 신뢰성보다 빠른 응답과 실시간성이 중요한 애플리케이션에 적합합니다.

- DNS (Domain Name System)
  - 도메인 이름을 IP 주소로 변환하는 시스템.
  - 빠른 쿼리 응답을 위해 UDP 사용.
  - 만약 응답을 받지 못하면, 클라이언트가 직접 재전송을 수행.
- VoIP (Voice over IP) / 실시간 스트리밍
  - 음성 및 영상 통신에서는 약간의 데이터 손실보다 낮은 지연 시간이 더 중요함.
  - 패킷이 손실되더라도 TCP처럼 재전송하지 않기 때문에 속도가 빠름.
- 온라인 게임
  - TCP의 흐름 제어나 혼잡 제어로 인해 속도가 늦어질 수 있음.
  - UDP를 사용하여 빠른 데이터 전송을 우선하며, 손실된 패킷은 게임 클라이언트가 자체적으로 처리.
- SNMP (Simple Network Management Protocol)
  - 네트워크 장치의 상태를 모니터링하는 프로토콜.
  - 빠른 데이터 수집이 필요하며 신뢰성보다는 실시간성이 중요.

# 코드 스쿼드 질문
## UDP 기반 DNS 프로토콜의 특징은 무엇이고 어떻게 동작하나요
### 특징
DNS(Domain Name System)는 주로 UDP를 사용하여 동작하는 프로토콜입니다. UDP를 사용하는 이유는 빠른 응답 속도와 간단한 전송 방식이 중요하기 때문입니다.

- 비연결형 (Connectionless):
  - DNS는 요청과 응답이 단순한 구조이므로, TCP처럼 핸드셰이킹을 할 필요가 없습니다.
  - 클라이언트는 UDP를 사용하여 단순히 DNS 서버에 요청을 보내고, 서버는 응답을 보냄.
- 빠른 속도:
  - UDP는 TCP와 달리 흐름 제어나 혼잡 제어가 없기 때문에 빠른 응답이 가능.
  - 웹페이지 로드 시 도메인 네임을 빠르게 IP 주소로 변환할 수 있음.
- 작은 데이터 크기:
  - 일반적인 DNS 응답은 512바이트 이하이며, 하나의 UDP 패킷으로 전송 가능.
  - 512바이트를 초과하는 경우 TCP로 전환되거나 DNS 메시지가 여러 개의 UDP 패킷으로 나뉘어 전송됨.
- 손실 가능성:
  - UDP는 신뢰성을 보장하지 않으므로, 요청이나 응답이 손실될 가능성이 있음.
  - 클라이언트는 일정 시간 응답이 없으면 다시 요청을 보냄 (재시도 메커니즘).

### DNS 프로토콜의 동작 방식
1. 사용자가 웹사이트 접속 요청
   - 사용자가 www.example.com에 접속하려고 하면, OS는 DNS Resolver를 통해 해당 도메인의 IP 주소를 찾음.
2. UDP 기반 DNS 쿼리 전송
   - 클라이언트는 UDP 포트 53을 사용하여 DNS 서버에 쿼리를 전송.
   - 예: "www.example.com의 IP 주소를 알려줘!"
3. DNS 서버의 응답
   - 서버는 데이터베이스에서 www.example.com의 IP 주소를 검색하여 응답.
   - 응답 메시지를 UDP 패킷으로 전송.
4. 클라이언트가 응답을 받아 웹사이트 접속
   - IP 주소를 받은 클라이언트는 웹서버에 HTTP 요청을 보냄.
5. 응답이 없을 경우 재시도 또는 다른 DNS 서버로 요청
   - 클라이언트는 일정 시간 동안 응답이 없으면 요청을 다시 보내거나, 다른 DNS 서버에 요청을 시도.

## TCP 기반 HTTP 프로토콜의 특징은 무엇이고 어떻게 동작하나요
### 특징
HTTP(HyperText Transfer Protocol)는 웹페이지를 로드하는 데 사용되는 프로토콜이며, TCP 기반으로 동작합니다.

- 연결 지향형 (Connection-oriented)
  - 클라이언트와 서버 간 3-way Handshake를 통해 연결을 설정하고 데이터를 전송.
  - 신뢰성을 보장하며, 손실된 데이터는 재전송됨.
- 신뢰성 보장
  - 모든 HTTP 요청과 응답이 순서대로 전달되도록 보장됨.
  - 데이터가 손실될 경우 TCP의 재전송 메커니즘을 통해 복구됨.
- 흐름 제어 및 혼잡 제어
  - 네트워크 혼잡 상황을 고려하여 데이터를 조절하며 전송.
- HTTP/1.1과 HTTP/2의 차이점
  - HTTP/1.1: 연결이 유지되지만 요청-응답 방식(단일 요청-단일 응답)이므로 성능이 제한됨.
  - HTTP/2: 멀티플렉싱 지원으로 여러 개의 요청을 동시에 처리할 수 있음.
- HTTP/3 (QUIC 기반)
  - TCP 대신 UDP를 기반으로 하는 QUIC 프로토콜을 사용하여 성능을 향상.

> QUIC (Quick UDP Internet Connection
>  - UDP 기반 → 빠른 연결 설정 가능 (TCP의 3-way Handshake 불필요).
> - TLS 1.3을 기본으로 사용 → 보안이 강화됨.
> - 스트림 다중화 지원 → TCP에서 발생하는 Head-of-line Blocking 문제 해결.
> - IP 주소가 바뀌어도 연결 유지 가능 (연결 마이그레이션 지원).

### HTTP 프로토콜의 동작 방식
1. 클라이언트가 웹페이지 요청
   - 사용자가 https://www.example.com을 브라우저에 입력.
2. DNS를 통해 서버 IP 주소 조회 (UDP)
   - 브라우저가 DNS 요청을 보내 IP 주소를 가져옴.
3. TCP 3-way Handshake
   - 클라이언트와 서버 간에 연결을 설정하기 위해 3-way Handshake 진행.
   - SYN → SYN-ACK → ACK 순서로 연결 확립.
4. HTTP 요청 전송 (GET, POST 등)
   - 클라이언트는 GET /index.html HTTP/1.1 요청을 보냄.
5. 서버가 요청을 처리하고 응답 전송
   - 웹서버는 HTML, CSS, JS 등의 웹페이지 데이터를 찾아 응답.
6. 데이터 전송 및 TCP 세그먼트 확인
   - TCP는 데이터의 손실 여부를 확인하고, 손실된 경우 재전송.
7. 웹페이지 렌더링 및 TCP 연결 종료
   - 모든 데이터가 전송되면 TCP 4-way Handshake로 연결을 종료.


# 참조
- https://dev-coco.tistory.com/144
- https://ramoo1101.tistory.com/69
- https://reallinux.co.kr/blog/241
- https://www.youtube.com/watch?v=xe-v5bRRQqw
- https://www.top10vpn.com/ko/guides/udp-vs-tcp/
- https://docs.tosspayments.com/resources/glossary/tcp
