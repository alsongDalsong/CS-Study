## 자료구조(Data structure) 기초

### [위키피디아 정의](https://en.wikipedia.org/wiki/Data_structure)

> In computer science, a data structure is a data organization and storage format that is usually chosen for efficient access to data.

- 자료구조는 데이터를 저장하고 관리하는 방식
- 효율적인 데이터 접근을 위해서 자료구조를 선택

### 자료구조의 종류

아래는 자료구조, 알고리즘 로드맵인데 [로드맵 링크](https://roadmap.sh/datastructures-and-algorithms)에 가시면 다양한 로드맵도 확인 할 수 있습니다. (2025년 업데이트 된거라 최신)

![자료구조, 알고리즘 로드맵](https://github.com/user-attachments/assets/5cd01edb-b5f7-4fca-915f-d5103431e00e)

데이터를 저장하고 관리하는 방식은 크게 선형, 비선형, 해시테이블을 사용한 자료구조 세 가지로 나뉘는 것 같습니다.

1. **선형구조**: 배열, 리스트(단일, 이중, 원형), 스택, 큐, 데크
2. **비선형구조**: 트리, 그래프
3. **해시테이블**

보통은 선형, 비선형으로 많이 나누지만 해시테이블의 경우 따로 분리하기 때문에 고민하다가 추가해줬습니다.

- 선형 자료구조의 정의: 데이터의 요소들의 관계가 1:1인 자료구조
- 비선형 자료구조의 정의: 데이터의 요소들의 관계가 1:n인 자료구조

### 선형 자료구조 간단 설명

- 사실 선형 자료구조의 경우 너무나도 익숙한 개념이지 않을까 싶습니다. 배열, 리스트, 스택, 큐... 굳이 설명이 필요할까요?
- 여기서 저는 그래도 개인적으로 짚고 넘어가고 싶었던 것이 개념적인 부분에 가까운 자료구조와 구현적인 부분에 가까운 자료구조입니다.
- 스택, 큐, 데크의 경우 구현에 가깝습니다. 배열이나 리스트를 가지고 어떻게 데이터를 쌓고 처리하느냐가 관건입니다.

#### 개념적인 부분에 가까운 자료구조

- 배열과 리스트가 이에 해당됩니다.
- 두개의 큰 차이는 연속된 메모리 블록에 쌓느냐, 연속되지 않는 메모리 블록에 쌓느냐의 차이인것 같습니다.
- 연속된 메모리 블록에 쌓지 않는다면 결국 다음 순서의 데이터가 어느 메모리에 있는지 포인터가 필요하고, 그 포인터를 저장하는 용량이 추가로 필요해집니다.

<img width="800" src="https://github.com/user-attachments/assets/fd779584-50fa-4a56-b8a9-f9d14f889487">

- 배열의 단점은 연속된 메모리 블록에 쌓기 때문에 무한한 메모리를 줄 수 없으니 한정된 메모리를 가지고 그곳에 쌓을 수 밖에 없습니다. 또한 삭제의 경우 연속되게 하기 위해서 한칸 한칸 당겨줘야 합니다.
- 리스트의 단점은 포인터가 있으므로 추가 데이터가 생기게 되고, 포인터를 통해 하나하나 접근해야 하기 때문에 느릴 수 밖에 없습니다. 이는 캐싱에도 영향을 미치게 됩니다.

#### "현대 컴퓨팅 환경에서 연결 리스트가 실용성이 떨어진다" 라는 주장?

- 제 의견 아니구요... 덴마크 컴퓨터 과학자가 `vector`(동적 배열)을 기본으로 사용하는 것을 추천한다는 이야기가 있습니다.

<img width="1300" src="https://github.com/user-attachments/assets/18e9cd56-011a-4a08-ba45-917b6f1b6e83">
<img width="1300" src="https://github.com/user-attachments/assets/187dc9dd-721a-4b3c-bce3-7776e60b9c98">

- 아 단순히 덴마크 컴퓨터 과학자 아니냐구요? Bjarne Stroustrup... C++ 창시자 입니다.

<img width="1262" src="https://github.com/user-attachments/assets/19f650c3-02e0-483f-a463-4bf930e9eeef" />

- 물론 이 글에서는 핵심 원칙을 지키면서 자료구조를 선택해야 한다는 주장입니다.
- 캐시 미스와 메모리 오버헤드로 인한 실제 성능 저하가 첫번째입니다.
  - 현대 CPU는 메모리 접근 패턴을 예측해 데이터를 미리 캐시하는데 순차적 접근 패턴을 쉽게 예측 가능한 배열에 비해 리스트는 불규칙한 접근 패턴을 가지고 있기 때문에 캐시 미스가 발생할 수 있다고 합니다.
- 리스트는 삭제, 추가가 O(1)이지만 삭제, 추가, 삭제할 대상 노드를 찾는데 결국 O(n)이 소모될 수 있습니다.
- 이론적 복잡도(O-표기법) ≠ 실제 성능, 캐시 미스, 메모리 접근 패턴이 성능을 좌우한다고 합니다.
- 다만 요소 자체가 크거나, 연속된 메모리 할당이 어려운 경우 리스트가 유리하지만 대부분의 현실적 시나리오에서는 벡터가 기본 선택지라고 합니다.

```
핵심 원칙
- 불필요한 데이터 저장을 피하라.
- 데이터를 컴팩트하게 유지하라.
- 메모리를 예측 가능한 방식으로 접근하라.
```

#### [Dynamic Array](https://en.wikipedia.org/wiki/Dynamic_array)

- 그렇다면 동적배열은 연결리스트도 아니면서 어떻게 동적으로 메모리가 할당 되는 것일까요?
- 배열을 미리 넉넉한 크기로 할당해둡니다.
- 공간이 부족하면 새로운 더 큰 배열을 할당하고 데이터를 복사합니다.

**동적 배열 vs. 연결 리스트 비교**

| 비교 항목       | **동적 배열 (Dynamic Array)** | **연결 리스트 (Linked List)** |
|---------------|----------------|----------------|
| **랜덤 접근** | ✅ O(1) | ❌ O(n) |
| **삽입/삭제 (중간)** | ❌ O(n) | ✅ O(1) |
| **삽입/삭제 (끝)** | ✅ O(1) (평균) | ✅ O(1) |
| **메모리 효율성** | ✅ 높음 (연속된 메모리) | ❌ 낮음 (포인터 오버헤드) |
| **캐시 친화도** | ✅ 높음 (연속된 메모리) | ❌ 낮음 (비연속 메모리) |
| **메모리 할당 방식** | ✅ 크기 조정 가능 (재할당 발생) | ✅ 동적 할당 (조각난 메모리 가능) |
| **성능 특성** | ✅ 빠른 읽기/쓰기 | ✅ 빠른 삽입/삭제 |

**언어별 동적 배열 구현**

| 언어 | 동적 배열 클래스 | 크기 증가 비율 |
|------|---------------|--------------|
| **C++** | `std::vector` | 2배 |
| **Java** | `ArrayList<E>` | 1.5배 |
| **C#** | `List<T>` | 2배 |
| **Python** | `list` | 1.125배 |
| **Rust** | `Vec<T>` | 2배 |
| **Go** | `slice` | 1.25~2배 |

#### 구현적인 부분에 가까운 자료구조

- 스택, 큐, 데크, 트리, 그래프의 경우 배열 또는 리스트를 사용하여 구현하는 자료를 저장하고, 접근하고, 수정하는 방식에 가깝습니다.
- 큐는 FIFO, 스택은 LIFO, 데크는 양쪽으로 데이터의 추가와 삭제가 가능하기만 하면 배열을 쓰던 리스트를 쓰던 상관 없습니다. (동적 배열을 주로 쓰겠네요)
- 실제로 트리같은 경우도 리스트로 할 것 같지만 동적 배열로도 충분히 가능합니다.

### Swift의 Array?

- Swift는 Array라고 정의했는데, 이 역시 모두가 알듯이 동적배열입니다. 과연 어떻게 메모리가 할당될까요?
- capacity라는 특성을 통해 알 수 있네요.

<img width="400" src="https://github.com/user-attachments/assets/4be871ed-8229-47a1-8597-f1735b59ff61">

<img width="800" src="https://github.com/user-attachments/assets/be72ceb0-c4d6-45a6-b0f4-b0720b32ba2c">

- 정말 타이트하게 관리하는군요... 공간이 부족할 경우 2배로 할당하네요.
- 라고 생각한다면 오산... 2 -> 4 -> 8 -> 16 -> 32 -> 64 -> 188 -> 380 -> 764 -> 1532 순으로 늘어나는데 (무슨 알고리즘이 들어간걸까요...?)

<img width="800" src="https://github.com/user-attachments/assets/ddf1ad5e-08fb-4b35-b3c3-1d39e3e5fdfd">

- 아래와 같이 capacity를 지정해서 사용할 수 있습니다.. 8까지는 8로 capacity가 되다가 넘어가니까 알아서 16으로 변경해주네요.

<img width="800" src="https://github.com/user-attachments/assets/f210b773-e4fb-4188-9708-68e773e50be8">

- 아래와 같이 COW도 확인을 살포시 해봤습니다 :) (참고로 메모리주소가 16진수 12자리, 48비트인걸 보니 64비트 시스템에서 16비트를 주소로 사용하지 않나보네요)

<img width="800" src="https://github.com/user-attachments/assets/7ee26d4c-bd91-4943-b6b2-7ccd81c10af2">

### 비선형 자료구조의 간단 설명

- 트리, 그래프... 아시죠? 노드들이 간선으로 연결되어 있는 구조입니다.
- 여기서 루트, 부모와 자식, 리프가 있고 순환된 연결구조가 없다면 트리구조라고 합니다.

<img width="600" src="https://github.com/user-attachments/assets/12d8ea92-deb9-4351-8f0b-2311400b4b58" />

- 트리구조는 계층적 데이터 저장, 효율적인 탐색이 정말 큰 장점이라고 생각합니다.

#### 이진 트리 (Binary Tree)

- 부모 노드 밑의 자식 노드 개수가 최대 2개인 트리입니다.

#### 이진 탐색 트리 (Binary Search Tree)

- 왼쪽 서브 트리는 노드보다 작은 값을 포함하고 오른쪽 서브 트리는 노드보다 큰 값을 포함합니다.

<img width="600" src="https://github.com/user-attachments/assets/40a21883-ebc6-4a8c-8aad-e4ec9fb07fd5">

#### AVL 트리 (Adelson-Velsky and Landis Tree)

- 자가 균형 이진 탐색 트리의 한 유형입니다.
- 각 노드의 서브트리 높이 차이가 최대 1을 유지하도록 스스로 균형을 유지하는 트리입니다.

<img width="600" src="https://github.com/user-attachments/assets/e8b8dd27-58dc-4e2e-ab88-3391a41d06ac">

#### B-트리

- 자가 균형 이진 탐색 트리의 한 유형입니다.
- 자식 노드의 최대 숫자가 2보다 큰 트리 구조입니다.

<img width="600" src="https://github.com/user-attachments/assets/29802099-8c88-47d0-9c32-456c67287111">
